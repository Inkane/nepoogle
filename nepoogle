#!/usr/bin/env python
# -*- coding: utf-8 -*-

import datetime, gettext, os, re, subprocess, sys, time

from PyQt4.QtCore import *
from PyQt4.QtGui import *
from PyQt4.QtWebKit import *
from PyKDE4.kdeui import *
from PyKDE4.nepomuk import *
from PyKDE4.soprano import *
#from PyKDE4.kdecore import ki18n, i18n, KCmdLineArgs, KAboutData
#from PyKDE4.kdeui import KApplication, KXmlGuiWindow, KStandardAction, KAction, KIcon
#from PyKDE4.kdecore import *
#from PyKDE4.kdeui import *

#_BUG: carácter ' de Singin' in the Rain
#_BUG: fallan las búsquedas con el carácter ":"
#_BUG: encoding incorrecto
#_BUG: sample rate se visualiza en notación científica
#_BUG: error: [Errno 5] Input/output error la llamar al programa sin la consola
#_BUG: uri incorrecta en el link al album de la pieza musical
#_TODO: visualizar las fechas correctamente
#_TODO: los links a visor deben funcionar con los discos desconectados

#BUG: Modifiers "+" and "-" were not working filtering commands.
#TODO: sort case insensitive, columna lower(?x) AS ?sort
#TODO: bif:lower(?x) in ('x', 'y', 'z')
#TODO: musicpiece debe de incluir el intérprete
#TODO: añadir soporte a nepomuk:/ en consola
#TODO: visor de álbum debería incluir los intérpretes/creadores del mismo y la carátula
#TODO: mostrar estrellas en el rating por coherencia
#TODO: añadir al resource viewer los siguientes links: . << < > >>
#TODO: implementar cache al moverse de atrás adelante (ojo con la vista por partes)
#TODO: count()
#select count(?x0) as ?cuantos
#where {
#{
#query a contar
#}
#}

#TODO: configuración externa
#TODO: multilenguage
#TODO: paréntesis
#TODO: editor: gestionar comentarios, rating y tags.
#TODO: soporte para la modificación de comentarios
#TODO: soporte para la modificación del rating
#TODO: soporte para la gestión de tags. Idea:
#       Más usados: los 10 tags más usados listados alfabéticamente.
#       Usados: los últimos tags usados, debajo los últimos que has usado.
#       Alfabética: la vista normal.
#       Botón de eliminar todos.
#TODO: añadir soporte a --connect, --disconnect, --daemonize y moverlos a Nepoogle

PROGRAM_NAME = os.path.basename(sys.argv[0])
PROGRAM_BASENAME = os.path.splitext(PROGRAM_NAME)[0]
PROGRAM_PATH = os.path.dirname(os.path.abspath(sys.argv[0]))
PROGRAM_VERSION_VERSION = 'v0.6'
PROGRAM_VERSION_DATE = '2011-10-??'
PROGRAM_AUTHOR_NAME = 'Ig'
PROGRAM_AUTHOR_EMAIL = 'kde@aynoa.net'
PROGRAM_HTML_POWERED = "<br />--<br /><b>Powered by</b> <em>%(name)s</em> <b>%(version)s</b> released (%(date)s)" \
                        % {'name': PROGRAM_NAME, \
                            'version': PROGRAM_VERSION_VERSION, \
                            'date': PROGRAM_VERSION_DATE \
                            }

RDF_SCHEMA_RESOURCE = 'http://www.w3.org/2000/01/rdf-schema#Resource'

gSysEncoding = 'utf-8' # Change this for a detection system.

knownOntologies = [ \
                    ['nao', '2007/08/15'], ['ncal', '2007/04/02'], \
                    ['nco', '2007/03/22'], ['nexif', '2007/05/10'], \
                    ['nfo', '2007/03/22'], ['nid3', '2007/05/10'], \
                    ['nie', '2007/01/19'], ['nmm', '2009/02/19'], \
                    ['nmo', '2007/03/22'], ['nrl', '2007/08/15'], \
                    ['pimo', '2007/11/01'], ['tmo',  '2008/05/20'] \
                ]

gettext.bindtextdomain(PROGRAM_NAME, '') #'/path/to/my/language/directory')
gettext.textdomain(PROGRAM_NAME)
_ = gettext.gettext
#gettext.translation(PROGRAM_NAME, languages=['es']).install()

                
def addLinksToText(text = ''):
    patter1 = re.compile(r"(^|[\n ])(([\w]+?://[\w\#$%&~.\-;:=,?@\[\]+]*)(/[\w\#$%&~/.\-;:=,?@\[\]+]*)?)", re.IGNORECASE | re.DOTALL)
    patter2 = re.compile(r"#(^|[\n ])(((www|ftp)\.[\w\#$%&~.\-;:=,?@\[\]+]*)(/[\w\#$%&~/.\-;:=,?@\[\]+]*)?)", re.IGNORECASE | re.DOTALL)

    text = patter1.sub(r'\1<a title="\2" href="\2" target="_blank">\3</a>', text)
    text = patter2.sub(r'\1<a title="http:/\2" href="http:/\2" target="_blank">\3</a>', text)

    return text


def fileExists(fileName = ''):
    if fileName == '':
        return False

    fileName = toUnicode(fileName)
    if fileName[:7] == 'file://':
        return os.path.exists(fileName[7:])

    else:
        return os.path.exists(fileName)


def formatDate(string = '', pack = False):
    result = datetime.datetime.strptime(string[:19], "%Y-%m-%dT%H:%M:%S")
    result = datetime.datetime.strftime(result, '%x')
    return result
    

def formatDateTime(string = '', pack = False):
    result = datetime.datetime.strptime(string[:19], "%Y-%m-%dT%H:%M:%S")
    if pack and result.day == 1 and result.month == 1 and (result.hour + result.minute + result.second) == 0:
        result = datetime.datetime.strftime(result, '%Y')

    else:
        result = datetime.datetime.strftime(result, '%x %X')
        
    return result

        
def fromPercentEncoding(url = ''):
    qurl = QUrl()
    qurl.setEncodedUrl(toUtf8(url))
    qurl.setEncodedUrl(toUtf8(qurl.toString()))
    qurl.setEncodedUrl(toUtf8(qurl.toString()))
    return toUnicode(qurl.toString())


def iif(condition = True, value = '', optionalValue = ''):
    return value if condition else optionalValue


def lindex(items, value, column = None):
    try:
        if vartype(items[0]) != 'list':
            column = None

        if column == None:
            result = next((i for i, element in enumerate(items) if value in element), None)

        else:
            result = next((i for i, element in enumerate(items) if value == element[column]), None)

    except:
        result = None

    return result


def lvalue(items, value, searchColumn = 0, valueColumn = 0):
    try:
        value = items[lindex(items, value, searchColumn)][valueColumn]

    except:
        value = None

    return value


def NOC(name = '', returnQUrl = False):
    ontology, property = name.strip().split(':')
    date = lvalue(knownOntologies, ontology, 0, 1)
    if date != None:
        value = 'http://www.semanticdesktop.org/ontologies/%s/%s#%s' % (date, ontology, property)

    else:
        value = 'Soprano.Vocabulary.%s.%s().toString()' % (ontology.upper(), property)
        try:
            value = eval(value)

        except:
            value = ''

    if returnQUrl:
        return QUrl(value)

    else:
        return value


def NOCR(ontology = ''):
    result = ''
    if ontology == '':
        return result

    return os.path.basename(toUnicode(ontology)).replace('#', ':').replace('rdf-schema:', 'rdfs:')

    

def ontologyToHuman(ontology = '', reverse = False):
    result = ''
    if ontology == '':
        return result

    try:
        ontology = ontology.split(':')[1]
        
    except:
        pass
        
    if ontology == '':
        return result

    result += ontology[0].upper()
    for i in range(1, len(ontology)):
        if ontology[i] == ontology[i].upper():
            result += ' ' + ontology[i].lower()

        else:
            result += ontology[i]

    if reverse:
        if result == 'Creator':
            result = 'Is creator of'

        elif result == 'Has tag':
            result = 'Is tag of'

        elif result == 'Performer':
            result = 'Is performer of'
            
        elif result == 'Series':
            result = 'Episodes'

    return result


def QStringListToString(stringList = []):
    result = ''
    for item in stringList:
        if result != '':
            result += ', '

        result += toUnicode(item)

    return result


def toN3(url = ''):
    if url[0] == '^':
        result = '^' + QUrl(url[1:]).toEncoded()

    else:
        result = QUrl(url).toEncoded()

    return result


def toPercentEncoding(url = ''):
    return QUrl.toPercentEncoding(url)


def toUtf8(string):
    try:
        if vartype(string) == 'QString':
            return string.toUtf8() # REVISAR: Esto no es coherente con el resto.

        else:
            return string.encode(gSysEncoding)

    except:
        return string


def toUnicode(string):
    try:

        if vartype(string) == 'QString':
            return unicode(str(string.toUtf8()), gSysEncoding)

        if vartype(string) == 'unicode':
            return string

        return unicode(string, gSysEncoding)

    except:
        return string


def vartype(var):
    return type(var).__name__


# begin nssparql.py
#
# nsSparqlBuilder class
#
class nsSparqlBuilder():

    _private_main_header = \
                            "SELECT DISTINCT %s\n" \
                            "WHERE {\n\n"
    _private_main_footer = "}\n"

    caseInsensitiveSort = True
    #columns = '*'
    # ?x0+>prefLabel ?x0*>url + si * opcional
    #columns = '?url ?title AS ?label ?prefLabel ?fullname ?altlabel min(?type) AS ?type'
    columns = '?url ?title ?prefLabel ?fullname ?altLabel'
    command = ''
    # [id, ['columns', [[id, 'ontology', optional, sort]...], [bsTypeFilter], [bsIndividualFilter]]]
    commands = [ \
                [_('--actors'), ['?x1 AS ?id ?x2 AS ?fullname', [[0, 'nco:fullname', True, False]], ['nmm:actor->nco:fullname'], ['nmm:actor->nco:fullname']]], \
                [_('--albums'), ['?x0 AS ?id ?url ?title', [[0, 'nie:title', True, True], [1, 'nie:url', True, True]], ['rdf:type=nmm:MusicAlbum'], ['nie:title']]], \
                [_('--audios'), ['?x0 AS ?id ?url ?title', [[0, 'nie:title', True, True], [1, 'nie:url', True, True]], ['rdf:type=nfo:Audio'], ['nie:title']]], \
                #[_('--connect'), ['', [], [], []]], \
                [_('--composers'), ['?x1 AS ?id ?x2 AS ?fullname', [[0, 'nco:fullname', True, False]], ['nco:composer->nco:fullname'], ['nco:composer->nco:fullname']]], \
                [_('--contacts'), ['?x0 AS ?id ?fullname', [[0, 'nco:fullname', True, True]], ['rdf:type=nco:Contact'], ['nco:fullname']]], \
                [_('--creators'), ['?x1 AS ?id ?x2 AS ?fullname', [[0, 'nco:fullname', True, False]], ['nco:creator->nco:fullname'], ['nco:creator->nco:fullname']]], \
                #[_('--daemonize'), ['', [], [], []]], \
                [_('--directors'), ['?x1 AS ?id ?x2 AS ?fullname', [[0, 'nco:fullname', True, False]], ['nmm:director->nco:fullname'], ['nmm:director->nco:fullname']]], \
                #[_('--disconnect'), ['', [], [], []]], \
                [_('--genres'), ['\'ont://nmm:genre\' AS ?id ?x1 AS ?genre', [[0, 'nco:genre', True, False]], ['nmm:genre'], ['nmm:genre']]], \
                [_('--help'), ['help', [], [], []]], \
                [_('--images'), ['?x0 AS ?id ?url ?title', [[0, 'nie:url', True, True], [1, 'nie:title', True, True]], ['rdf:type=nfo:RasterImage'], ['nie:url']]], \
                [_('--movies'), ['?x0 AS ?id ?url ?title', [[0, 'nie:title', True, True], [1, 'nie:url', True, True]], ['rdf:type=nmm:Movie'], ['nie:title']]], \
                [_('--musicpieces'), ['?x0 AS ?id ?url ?title', [[0, 'nie:title', True, True], [1, 'nie:url', True, True]], ['rdf:type=nmm:MusicPiece'], ['nie:title']]], \
                [_('--performers'), ['?x1 AS ?id ?x2 AS ?fullname', [[0, 'nco:fullname', True, False]], ['nmm:performer->nco:fullname'], ['nmm:performer->nco:fullname']]], \
                [_('--producers'), ['?x1 AS ?id ?x2 AS ?fullname', [[0, 'nco:fullname', True, False]], ['nmm:producer->nco:fullname'], ['nmm:producer->nco:fullname']]], \
                [_('--quit'), ['quit', [], [], []]], \
                [_('--tags'), ['?x0 AS ?id ?prefLabel ?altLabel', [[0, 'nao:prefLabel', True, True], [2, 'nao:altLabel', True, True]], ['rdf:type=nao:Tag'], ['rdf:type=nao:Tag->nao:identifier']]], \
                [_('--tvseries'), ['?x0 AS ?id ?url ?title', [[0, 'nie:title', True, True], [1, 'nie:url', True, True]], ['rdf:type=nmm:TVSeries'], ['nie:title']]], \
                [_('--tvshows'), ['?x0 AS ?id ?url ?title', [[0, 'nie:url', True, True], [1, 'nie:title', True, True]], ['rdf:type=nmm:TVShow'], ['nie:title']]], \
                [_('--videos'), ['?x0 AS ?id ?url ?title', [[0, 'nie:title', True, True], [1, 'nie:url', True, True]], ['rdf:type=nfo:Video'], ['nie:title']]], \
                [_('--writers'), ['?x1 AS ?id ?x2 AS ?fullname', [[0, 'nco:fullname', True, False]], ['nmm:writer->nco:fullname'], ['nmm:writer->nco:fullname']]] \
            ]
    #fields = [[0, 'rdf:type', True], [1, 'nao:identifier', True], [2, 'nie:url', True], [3, 'nie:title', False], [4, 'nao:prefLabel', False],
    #            [5, 'nao:description', False], [6, 'nao:numericRating', False]]
    # 'nmm:genre', 'nmm:releaseDate', ''
    fields = [ \
                [0, 'nie:url', True, True], \
                [1, 'nie:title', True, True], \
                [2, 'nao:prefLabel', True, True], \
                [3, 'nco:fullname', True, True], \
                [4, 'nao:altLabel', True, True], \
                [5, 'rdf:type', True, False] \
            ]
    filters = []
    
    getAllFields = True
    #ontologyFilters = ['_nao:description', '_nao:identifier', '/nie:url', 'nao:hasTag->$nao:identifier', '%nie:plainTextContent']
    #ontologyFilters = ['_nao:description', '_nao:identifier', '_nie:url', 'nao:hasTag->$nao:identifier']
    ontologyFilters = ['nao:description', '%nao:identifier', '%nie:url', 'nao:hasTag->%nao:identifier', 'nco:fullname', 'nie:title']
    # All in lowercase so search in lowercase.
    ontologyTypes = [ \
                        ['nao:created', 'datetime'], \
                        ['nao:lastmodified', 'datetime'], \
                        ['nao:numericrating', 'number'], \
                        ['nfo:samplerate', 'number'], \
                        ['nfo:averagebitrate', 'number'], \
                        ['nie:contentcreated', 'datetimep'], \
                        ['nie:lastmodified', 'datetime'], \
                        ['nmm:episodenumber', 'number'], \
                        ['nmm:tracknumber', 'number'], \
                        ['nmm:season', 'number'], \
                        ['nmm:setnumber', 'number'], \
                        ['nuao:usagecount', 'number'] \
                    ]
    shortcuts = [ \
                    #TODO: singulares y plurales para todo
                    ['_nmm:actor->nco:fullname',_('actor'),  _('ac')], \
                    #TODO: fix actors shortcut
                    #['nmm:actor->nco:fullname', _('actors', _('acs'], \
                    #  optional { ?x0 nmm:actor ?x00 . ?x00 nco:fullname ?fullname . }
                    #  HAVING (REGEX(?fullname, '', 'i'))
                    ['nmm:musicAlbum->nie:title', _('album'), _('al')], \
                    ['rdf:type=nmm:MusicAlbum->nie:title',_('albums'), _('als')], \
                    ['nao:altLabel', _('altlabel'), _('all')], \
                    ['_nmm:composer->nco:fullname', _('composer'), _('cm')], \
                    ['?ont->nco:fullname', _('contact'), _('co')], \
                    ['rdf:type=nco:Contact->nco:fullname', _('contacts'), _('cos')], \
                    ['_nco:creator->nco:fullname', _('creator'), _('cr')], \
                    ['nao:description', _('description'), _('de')], \
                    ['_nmm:director->nco:fullname', _('director'), _('di')], \
                    ['nmm:setNumber', _('discnumber'), _('dn')], \
                    ['nmm:episodeNumber', _('episode'), _('ep')], \
                    ['nco:fullname', _('fullname'), _('fn')], \
                    ['nmm:genre', _('genre'), _('ge')], \
                    ['_nao:hasTag->%nao:identifier', _('hastag'), _('ht')], \
                    ['nie:mimeType', _('mimetype'), _('mt')], \
                    ['rdf:type=nmm:MusicPiece->nie:title',_('musicpieces'),  _('mps')], \
                    ['rdf:type=nmm:Movie->nie:title', _('movie'), _('mo')], \
                    ['nie:url', _('name'), _('na')], \
                    ['nao:numericRating', _('numericrating'), _('nr')], \
                    ['_nmm:performer->nco:fullname', _('performer'), _('pe')], \
                    ['_nmm:producer->nco:fullname', _('producer'), _('pr')], \
                    ['nuao:usageCount', _('playcount'), _('pc')], \
                    ['nao:prefLabel', _('preflabel'), _('pl')], \
                    ['nao:numericRating', _('rating'), _('ra')], \
                    ['nmm:season', _('season'), _('se')], \
                    ['nmm:setNumber', _('setnumber'), _('sn')], \
                    ['nao:identifier', _('tag'), _('ta')], \
                    ['nie:title', _('title'), _('ti')], \
                    ['nmm:trackNumber', _('tracknumber'), _('tn')], \
                    ['nmm:series->nie:title', _('tvserie'), _('ts')], \
                    ['rdf:type=nmm:TVSeries->nie:title', _('tvseries'), _('tvs')], \
                    ['nmm:series->nie:title', _('tvshow'), _('tv')], \
                    ['rdf:type', _('type'), _('ty')], \
                    ['%nie:url', _('url'), _('ur')], \
                    ['nuao:usageCount', _('usagecount'), _('uc')], \
                    ['_nmm:writer->nco:fullname', _('writer'), _('wr')] \
                ]

    tempData = ['', [], [], []]
    
    #typeFilters = ['nao#Tag', 'nfo#FileDataObject']
    typeFilters = []

    resultsetLimit = 0
    resultsetOffset = 0

    sortSuffix = '_sort'
    stdoutQuery = False
    

    def __init__(self):
        pass


    def __del__(self):
        pass


    def buildQuery(self, searchString = ''):

        if ((self.command == '') and (self.filters == []) and (searchString != '')):
            self.filters = self.stringQueryConversion(searchString)

        command = self.command.strip().lower()
        if command == '':
            pass
        
        else:
            idx = lindex(self.commands, command, 0)
            if idx >= 0:
                if self.commands[idx][1][0] == '':
                    raise Exception("Sorry, command \"%s\" not implemented yet." % self.command)

                else:
                    self.tempData = self.commands[idx][1]

            else:
                raise Exception("Unknown command \"%s\", try \"--help\" command." % self.command)

            # La ayuda tiene tratamiento especial
            if self.tempData[0] == 'help':
                raise Exception(self.tempData[0])

        if self.tempData[0] == '':
            columns = self.columns

        else:
            columns = self.tempData[0]

        footer = self._private_main_footer
        having = self.bsHaving()
        sort, sortColumns = self.bsSort()
        limits = self.bsResulsetLimits()

        columns += sortColumns
        header = self._private_main_header % columns

        typeFilter = self.bsTypeFilter() + '\n'
        if self.getAllFields:
            fields = self.bsFields() + '\n'

        else:
            fields = ''

        searchFilter = self.bsFilter() + '\n'

        query = header \
                + typeFilter \
                + fields \
                + searchFilter \
                + footer \
                + having \
                + sort \
                + limits

        if self.stdoutQuery:
            print toUtf8(query)

        self.tempData = ['', [], [], []]
        
        return query


    def bsFields(self):
        if self.tempData[1] == []:
            fields = self.fields

        else:
            fields = self.tempData[1]
            
        text = ""
        for item in fields:
            if not item[3]:
                continue

            try:
                text += "  optional { ?x0 %(ontology)s ?%(field)s . }\n" \
                            % {'ontology': item[1], 'field': item[1].split(":")[1]}

            except:
                pass

        return text


    def ontologyConversion(self, ontology = ''):
        ont = ontology.strip().lower()

        if ont == '':
            ontology = ''
        
        elif ont.find(':') > 0:
            pass
          
        else:
            idx = lindex(self.shortcuts, ont, 1)
            if idx == None:
                # Miramos en las abreviaturas.
                idx = lindex(self.shortcuts, ont, 2)

            if idx >= 0:
                ontology = self.shortcuts[idx][0]

            else:
                raise Exception("Unknown ontology \"%s\"." % ontology)

        return ontology


    def bsIndividualFilter(self, value = ''):
        ontologies = [self.ontologyConversion(value[2])]
        if ontologies == ['']:
            if self.tempData[3] == []:
                ontologies = self.ontologyFilters
             
            else:
                ontologies = self.tempData[3]

        text = ""
        for item in ontologies:
            textAux = ""
            ontologyElements = item.split("->")
            i = 0
            optionalUsage = False
            for ontology in ontologyElements:
                ontology = ontology.strip()

                try:
                    val = value[0]

                except:
                    val = ""

                try:
                    operator = value[1]
                    if operator == '':
                        operator = '='

                except:
                    operator = '='
                    
                valType = ""
                if ontology[0] == '%':
                    ontology = ontology[1:]
                    val = toN3(val)

                elif ontology[0] == '_':
                    ontology = ontology[1:]
                    optionalUsage = optionalUsage or (operator == '!=')

                valType = self.ontologyVarType(ontology)
                #optionalUsage = (optionalUsage and (operator == '!='))
                if not optionalUsage:
                    if ontology.find('=') >= 0:
                        textAux += "?x%(v1)s %(ont)s %(v2)s . " % {'ont': ontology.split('=')[0], 'v1': i, 'v2': ontology.split('=')[1]}

                    else:
                        textAux += "?x%(v1)s %(ont)s ?x%(v2)s . " % {'ont': ontology, 'v1': i, 'v2': i + 1}
                        i += 1

            if val == '':
                filterExpression = '}\n'

            else:
                # Sometimes " character must be removed.
                if val[0] == val[-1] == '"':
                    val = val[1:-1]
                    
                if valType == 'number':
                    filterExpression = "FILTER(?x%(v2)s %(op)s %(val)s) }\n" % {'v2': i, 'op': operator, 'val': val}

                else:
                    if operator == '==':
                        filterExpression = "FILTER(?x%(v2)s %(op)s \"%(val)s\"^^xsd:string) }\n" % {'v2': i, 'op': "=", 'val': val}

                    elif operator == '=':
                        filterExpression = "FILTER(REGEX(?x%(v2)s, \"%(val)s\"^^xsd:string, 'i')) }\n" % {'v2': i, 'val': val.replace('(', '\\\(').replace(')', '\\\)')}

                    elif operator == '!=':
                        if optionalUsage:
                            filterExpression = "?x%(v1)s %(ontbase)s ?x%(v2)s . optional { ?x%(v2)s %(ont)s ?x%(v3)s . FILTER(!REGEX(?x%(v3)s, \"%(val)s\"^^xsd:string, 'i')) } FILTER(!BOUND(?x%(v3)s)) }\n" \
                                                    % {'v1': i, 'v2': i+1, 'v3': i+2, 'val': val.replace('(', '\\\(').replace(')', '\\\)'), 'ontbase': ontologyElements[0][1:], 'ont': ontology}

                        else:
                            filterExpression = "FILTER(!REGEX(?x%(v2)s, \"%(val)s\"^^xsd:string, 'i')) }\n" % {'v2': i, 'val': val.replace('(', '\\\(').replace(')', '\\\)')}

                    else:
                        filterExpression = "FILTER(?x%(v2)s %(op)s \"%(val)s\"^^xsd:string) }\n" % {'v2': i, 'op': operator, 'val': val}

            if optionalUsage:
                        #"      }\n" \
                        #"    ))\n" \
                        #"    &&\n" \
                textAux = \
                        "    (!bif:exists ((\n" \
                        "      SELECT *\n" \
                        "      WHERE {\n" \
                        "        { " + textAux + filterExpression

            else:
                if text != "":
                    text += "      UNION\n"
                    textAux = "        { " + textAux + filterExpression

                else:
                    textAux = "    (bif:exists ((\n" \
                                "      SELECT *\n" \
                                "      WHERE {\n" \
                                "        { " + textAux + filterExpression

            text += textAux

        if text != "":
            if text[0] == '!':
                text += \
                            "      }\n" \
                        "    )))\n" \

            else:
                text = \
                                    "%(text)s" \
                            "      }\n" \
                        "    )))\n" \
                        % {'text': text}

        return text


    def bsFilter(self):
        filters = self.filters
        text = ""
        for item in filters:
            if item == []:
                continue
            
            if item[0].lower() == 'or':
                text += '    ||\n'

            elif item[0].lower() == 'and':
                text += '    &&\n'

            else:
                if text != "" and text[-2] == ')':
                    text += '    &&\n'
                text += self.bsIndividualFilter(item)

        if text != "":
            text = \
                    "  FILTER(\n" \
                        "%s" \
                    "  )\n" \
                    % text

        return text


    def bsHaving(self):
        return '\n'
        #return "HAVING !(?type = <http://www.w3.org/2000/01/rdf-schema#Resource>)\n"
        #return "HAVING (?type = <http://www.w3.org/2000/01/rdf-schema#Resource>)\n"
        #return "GROUP BY (?x0)\n"


    def bsSort(self):
        if self.tempData[1] == []:
            fields = self.fields

        else:
            fields = self.tempData[1]

        sortText = ""
        sortColumns = ""
        for item in fields:
            if item[2]:
                try:
                    columnName = "?" + item[1].split(":")[1] 
                    sortText += columnName
                    if self.caseInsensitiveSort:
                        sortColumns += " bif:lower(%s) AS %s%s " % (columnName, columnName, self.sortSuffix)
                        sortText += self.sortSuffix + ' '

                    else:
                        sortText += ' '

                except:
                    pass

        if sortText != "":
            sortText = "ORDER BY " + sortText + "\n"

        return sortText, sortColumns


    def bsTypeFilter(self):
        text = ""
        if self.tempData[2] == []:
            typeFilters = self.typeFilters

        else:
            typeFilters = self.tempData[2]

        if len(typeFilters) == 1:
            items = typeFilters[0].split("->")
            if len(items) > 1:
                i = 0
                text = ''
                #oldVarName = 'x0'
                for item in items:
                    if item != '':
                        #varName = items[i].split(':')[-1]
                        text += "  ?x%(oldVarName)s %(ontology)s ?x%(varName)s .\n" \
                                % {'oldVarName': i, 'varName': i+1, 'ontology': item}
                        #oldVarName = varName
                        i += 1

            else:
                items = typeFilters[0].split("=")
                if len(items) > 1:
                    text += "  ?x0 %(ontology1)s %(ontology2)s .\n" \
                            % {'ontology1': items[0], 'ontology2': items[1]}

                else:
                    text += "  ?x0 %(ontology)s ?x1 .\n" \
                            % {'ontology': items[0]}

        else:
            #TODO: cambiar el rdf:type igual que arriba.
            for item in typeFilters:
                if text != '':
                    text += '        UNION\n'
                text += '        { ?x0 rdf:type %s . }\n' % item

            if text != "":
                text = \
                        "  ?x0 rdf:type ?type .\n" \
                        "  FILTER(\n" \
                            "    bif:exists ((\n" \
                                "      SELECT *\n" \
                                "      WHERE {\n" \
                                "%s" \
                                "      }\n" \
                            "    ))\n" \
                        "  )\n" \
                        % text

            else:
                text = \
                        "  ?x0 rdf:type ?type .\n" \

        return text


    def bsResulsetLimits(self):
        text = ''
        if self.resultsetLimit > 0:
            text += "LIMIT %s\n" % self.resultsetLimit

        if self.resultsetOffset > 0:
            text += "OFFSET %s" % self.resultsetOffset

        return text


    def addField(self, name = ''):
        pass


    def removeField(self, name = '', logop = ''):
        pass


    def addFilter(self, name = ''):
        pass


    def removeFilter(self, name = ''):
        pass


    def addOntologyFilter(self, name = ''):
        pass


    def removeOntologyFilter(self, name = ''):
        pass


    def addTypeFilter(self, name = ''):
        pass


    def removeTypeFilter(self, name = ''):
        pass


    def setOrder(self, orderList = []):
        pass


    def ontologyVarType(self, ontology = ''):
        return lvalue(self.ontologyTypes, ontology.lower().strip(), 0, 1)
        
        
    def split(self, string = ''):
        #print string
        specialChars = [":", "+", "-", ">", "<", "="]
        result = []
        if string != '':
            breakChar = ' '
            newItem = True
            for i in range(0, len(string)):
                #print breakChar, string[i], result
                if string[i] == breakChar:
                    if breakChar in ("'", '"'):
                        result[-1] += breakChar
                        
                    newItem = True
                    breakChar = ' '
                    continue

                if ((string[i] == '"' or string[i] == "'")):
                    if ((i == 0) or (string[i-1] not in specialChars)):
                        if string[i] == breakChar:
                            newItem = True

                    if breakChar == ' ':
                        breakChar = string[i]
                    
                if newItem and ((result == []) or (result[-1] != '')):
                    result += ['']
                    newItem = False
                    
                result[-1] += string[i]

       #print 'Result:', result
        return result

        
    def stringQueryConversion(self, string = ''):
        if string == '':
            raise Exception("Type something to start querying.")

        allFilters = []
        oneFilter = []
        items = self.split(string)
        #print toUtf8(string)
        #print toUtf8(items)

        commandFound = False
        addAnd = False
        for item in items:
            if item[:2] == '--':
                commandFound = True
                oneFilter = [item, '', '']
          
            elif item.lower() == 'or':
                oneFilter = ['or', '', '']
                addAnd = False

            elif item.lower() == 'and':
                oneFilter = ['and', '', '']
                addAnd = False

            else:
                if addAnd == True:
                    allFilters += [['and', '', '']]

                ontology = ''
                while True:
                    if item[0] in ('"', "'") and item[-1] in ('"', "'"):
                        parts = [item[1:-1], '', '']

                    else:
                        parts = item.partition(':')

                    if parts[1] == ':':
                        ontology += parts[0] + ':'
                        item = parts[2]

                    else:
                        ontology = ontology[0:-1]
                        data = parts[0]
                        break

                if data == '':
                    raise Exception(_("Syntax error, please check your search text."))

                if data == '':
                    operator = ''
                    
                else:
                    operator = data[0]
                    
                if operator == '-':
                    operator = '!='
                    data = data[1:]

                elif operator == '+':
                    operator = '=='
                    data = data[1:]

                elif operator == '>':
                    operator = data[1]
                    if operator == '=':
                        operator = '>='
                        data = data[2:]

                    else:
                        operator = '>'
                        data = data[1:]

                elif operator == '<':
                    operator = data[1]
                    if operator == '=':
                        operator = '<='
                        data = data[2:]

                    else:
                        operator = '<'
                        data = data[1:]

                else:
                    operator = '='

                if (data[0] == data[-1] == '"') or (data[0] == data[-1] == "'"):
                    data = data[1:-1]
                
                oneFilter = [data, operator, ontology]
                addAnd = True

            allFilters += [oneFilter]

        # Check basic errors.
        if allFilters[len(allFilters)-1][0] == 'and' or allFilters[len(allFilters)-1][0] == 'or':
            allFilters = []
            raise Exception(_("Syntax error, please check your search text."))
          
        if (commandFound and (len(allFilters) > 1)):
            allFilters = []
            raise Exception(_("Syntax error, commands and queries are mutual exclude."))

        # ¿Es un comando?
        if ((len(allFilters) == 1) and (allFilters[0][0][:2] == "--")):
            dummy = allFilters[0][0].split(':')
            self.command = dummy[0]
            if ((len(dummy) > 1) and (dummy[1] != "")):
                if dummy[1][0] == '-':
                    allFilters = [[dummy[1][1:], '!=', '']]

                elif dummy[1][0] == '+':
                    allFilters = [[dummy[1][1:], '==', '']]

                else:
                    allFilters = [[dummy[1], '=', '']]

            else:
                allFilters = []

        return allFilters

        
    def executeQuery(self, query = []):
        model = Nepomuk.ResourceManager.instance().mainModel()

        queryTime = time.time()
        result = model.executeQuery(query, Soprano.Query.QueryLanguageSparql)
        queryTime = time.time() - queryTime
        
        structure = []
        data = []
        
        if result.isValid():
            for bindings in result.allBindings():
                if structure == []:
                    for bindingName in bindings.bindingNames():
                        structure += [toUnicode(bindingName.toUtf8())]
                
                aRow = []
                for bindingName in bindings.bindingNames():
                    #value = toUnicode(toPercentEncoding(bindings[bindingName].toString()))
                    value = toUnicode(bindings[bindingName].toString())

                    if value != '':
                        # Fields to case insensitive sort must be ignored.
                        if bindingName[-len(self.sortSuffix):] == self.sortSuffix:
                            continue
                            
                        elif bindingName == 'type':
                            value = os.path.basename(toUnicode(value))
                            value = value.split("#")
                            try:
                                value = '[' + value[1] + ']'

                            except:
                                value = value[0]

                        elif value[:7] == 'file://' or value[:7] == 'http://' or value[:8] == 'https://':
                            # Novedad en kde 4.7.0
                            qurl = QUrl()
                            qurl.setEncodedUrl(toUtf8(value))
                            value = toUnicode(qurl.toString())
                            # Novedad en kde 4.7.0
                            
                        aRow += [value]

                if len(aRow) > 0:
                    if len(aRow) < len(structure):
                        for i in range(len(aRow), len(structure)):
                            aRow += ['']
                        
                    data += [aRow]
                    
            result.close()

        else:
            result.close()
            raise Exception('Can\'t execute query, check syntax and test if Nepomuk is running.')

        return data, structure, queryTime

# end nssparql.py


#class nCompleter(QCompleter):

    #separator = " "
    
    #def __init__(self, *args):

        #QCompleter.__init__(self, *args)
        
        #model = QStringListModel()
        #wordList = [ \
                    #u"and", u"or",\
                    #u"actor:", \
                    #u"album", \
                    #u"creator", \
                    #u"director:", \
                    #u"genre", \
                    #u"hasTag:", \
                    #u"name:", \
                    #u"performer", \
                    #u"preflabel:", \
                    #u"rating:", \
                    #u"tag:", \
                    #u"title:", \
                    #u"url:", \
                    #u"writer:", \
                    #u"--help", \
                    #u"--allActors", \
                    #u"--allAlbums", \
                    ##u"--allCreators", \
                    #u"--allDirectors", \
                    #u"--allGenres", \
                    #u"--allPerformers", \
                    #u"--allTags", \
                    #u"--allWriters" \
                    #]

        #model.setStringList(wordList)
        #self.setModel(model)
        #self.setCaseSensitivity(Qt.CaseInsensitive);
        #self.setModelSorting(QCompleter.CaseSensitivelySortedModel)
        
        ##self.setCompletionMode(QCompleter.PopupCompletion)
        ##self.setCompletionMode(QCompleter.InlineCompletion)

        
    #def pathFromIndex(self, index):
        #path = QCompleter.pathFromIndex(self, index)

        #lst = str(self.widget().text()).split(self.separator)
        #if len(lst) > 1:
            #path = '%s%s%s' % (self.separator.join(lst[:-1]), self.separator, path)

        #return path

        
    #def splitPath(self, path):
        #path = str(path.split(self.separator)[-1]).lstrip(self.separator)
        #return [path]


#
# nWebView class
#
class nWebView(QWebView):

    def __init__(self, *args):
        QWebView.__init__(self, *args)
      
        #self.setContextMenuPolicy(Qt.PreventContextMenu)
        #self.setContextMenuPolicy(Qt.CustomContextMenu)
        self.page().setLinkDelegationPolicy(QWebPage.DelegateAllLinks)

    
    def customContextMenuRequested(self, pos):
        print 'customContextMenuRequested'

#
# Nepoogle class
#
class Nepoogle(QWidget):
    iconDelete = KIconLoader().iconPath('edit-delete', KIconLoader.NoGroup)
    iconDocumentInfo = KIconLoader().iconPath('documentinfo', KIconLoader.NoGroup)
    iconDocumentProp = KIconLoader().iconPath('document-properties', KIconLoader.NoGroup)
    iconFileManager = KIconLoader().iconPath('system-file-manager', KIconLoader.NoGroup)
    iconKonqueror = KIconLoader().iconPath('konqueror', KIconLoader.NoGroup)
    iconProcessIdle = KIconLoader().iconPath('process-idle', KIconLoader.NoGroup)
    iconSystemRun = KIconLoader().iconPath('system-run', KIconLoader.NoGroup)
    iconSystemSearch = KIconLoader().iconPath('system-search', KIconLoader.NoGroup)

    model = None
    queries = []
    queriesIndex = -1
    sparql = None
    
    pendingQuery = False

    renderedCache = ''
    renderedRows = 0
    renderSize = 50

    resultData = []
    resultStructure = []
    resultTime = None

    htmlFooter = "%s</body>\n</html>\n" % PROGRAM_HTML_POWERED
    htmlHeader = "<html>\n" \
                    "<head>\n" \
                    "<style type=\"text/css\">" \
                    "    body {%(body_style)s}\n" \
                    "    tr {%(tr_style)s}\n" \
                    "    p {%(p_style)s}\n" \
                    "</style>\n" \
                    % {'body_style': "font-size:small;", \
                        'p_style': "font-size:small;", \
                        'tr_style': "font-size:small;" \
                        } \
                    + "<title>%(title)s</title>\n" \
                        "    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n" \
                        "</head>\n<body>\n"
    htmlImgStyle = "align=\"bottom\" border=\"0\" hspace=\"0\" vspace=\"0\" style=\"width: 14px; height: 14px;\""
    htmlTableHeader = "<table style=\"text-align:left; width: 100%%;\" " \
                        "border=\"%(border)s\" cellpadding=\"%(cellpadding)s\" cellspacing=\"0\">" \
                        "<tbody>\n"
    htmlTableFooter = "</tbody></table>\n"
    htmlTime = "<br />\n%(records)s records found in %(seconds)s seconds. \
                HTML visualization builded in %(sechtml)s seconds."
                

    htmlLinkDolphin = "<a href=\"dolp:/%s\"><img %s title=\"%s\" src=\"file://%s\"></a>" \
                        % ('%s', htmlImgStyle, 'open with Dolphin', iconFileManager)
    htmlLinkInfo = "<img %s src=\"file://%s\">" % (htmlImgStyle, iconDocumentInfo)
    htmlLinkKonqueror = "<a href=\"konq:/%s\"><img %s title=\"%s\" src=\"file://%s\"></a>" \
                        % ('%s', htmlImgStyle, 'open with Konqueror', iconKonqueror)
    htmlLinkOpenLocation = "<a href=\"%s\"><img %s title=\"%s\" src=\"file://%s\"></a>" \
                            % ('%s', htmlImgStyle, 'open location', iconFileManager)
    htmlLinkProperties = "<a href=\"prop:/%s\"><img %s title=\"%s\" src=\"file://%s\"></a>" \
                            % ('%s', htmlImgStyle, 'properties', iconDocumentInfo)
    htmlLinkRemove = "<a href=\"remove:/%s\"><img %s title=\"%s\" src=\"file://%s\"></a>" \
                            % ('%s', htmlImgStyle, 'remove resource', iconDelete)
    htmlLinks = "<td width=\"65px\">%s</td>"
    htmlLinkSearch = "<img %s src=\"file://%s\">" % (htmlImgStyle, iconSystemSearch)
    htmlLinkSystemRun = "<a href=\"%s\"><img %s title=\"%s\" src=\"file://%s\"></a>" \
                            % ('%s', htmlImgStyle, 'system run', iconSystemRun)


    def __init__(self, parent = None, string = ''):
        QWidget.__init__(self, parent)

        self.model = Nepomuk.ResourceManager.instance().mainModel()

        #self.setGeometry(300, 300, 250, 150)
        #self.setWindowTitle(os.path.basename(sys.argv[0]))
        self.setWindowTitle(PROGRAM_NAME)
        #self.setWindowIcon(QIcon('icon.png'))
        self.setWindowIcon(QIcon(KIconLoader().loadIcon('nepomuk',  KIconLoader.NoGroup,  KIconLoader.SizeSmall)))

        self.leSearch = QLineEdit(self)
        #self.leSearch.setCompleter(nCompleter())
        self.leSearch.selectOnEntry = True

        self.pbBackward = QPushButton(self)
        self.pbBackward.setIcon(QIcon(KIconLoader().loadIcon('go-previous',  KIconLoader.NoGroup,  KIconLoader.SizeSmall)))
        #self.pbBackward.setGeometry(QRect(self.leSearch.height(), self.leSearch.height(), self.leSearch.height(), self.leSearch.height()))
        self.connect(self.pbBackward, SIGNAL("clicked()"), self.goBackward)
    
        self.pbForward = QPushButton(self)
        self.pbForward.setIcon(QIcon(KIconLoader().loadIcon('go-next',  KIconLoader.NoGroup,  KIconLoader.SizeSmall)))
        #self.pbForward.setGeometry(QRect(self.leSearch.height(), self.leSearch.height(), self.leSearch.height(), self.leSearch.height()))
        self.connect(self.pbForward, SIGNAL("clicked()"), self.goForward)

        self.hbl = QHBoxLayout()
        self.hbl.setSpacing(1)
        self.hbl.addWidget(self.pbBackward)
        self.hbl.addWidget(self.pbForward)
        self.hbl.addWidget(self.leSearch)

        self.wvOutput = nWebView(self)
        self.connect(self.wvOutput, SIGNAL("linkClicked(const QUrl&)"), self.linkClicked)
        self.connect(self.wvOutput, SIGNAL("loadStarted()"), self.loadStarted)
        self.connect(self.wvOutput, SIGNAL("loadFinished(bool)"), self.loadFinished)
        self.connect(self.wvOutput, SIGNAL("loadProgress(int)"), self.loadProgress)
        self.connect(self.wvOutput.page(), SIGNAL("customContextMenuRequested(const QPoint&)"), self.customContextMenuRequested)

        self.grid = QGridLayout()
        self.grid.setSpacing(10)
        #self.grid.addWidget(self.leSearch, 1, 1)
        self.grid.addLayout(self.hbl, 1, 1)
        self.grid.addWidget(self.wvOutput, 2, 1, 5, 1)

        self.setLayout(self.grid)

        self.resize(680, 510)
        if string == '':
            self.leSearch.setText(toUnicode('Type search here'))

        else:
            self.leSearch.setText(string)

        self.leSearch.setSelection(0,999)
        self.leSearch.setFocus()
        
        if string == '':
            self.execQuery('--help')

    
    def customContextMenuRequested(self, pos):
        print 'customContextMenuRequested'


    def loadFinished(self, ok):
        #print 'loadFinished:', ok
        self.repaint()
        if self.pendingQuery:
            self.execQuery()

            
    def loadProgress(self, progress):
        #print 'loadProgress:', progress
        pass

        
    def loadStarted(self):
        #print 'loadStarted'
        pass


    def keyPressEvent(self, event):
        if event.key() == Qt.Key_Return or event.key() == Qt.Key_Enter:
            self.pendingQuery = True
            self.wvOutput.setHtml('<html><body><h3>Searching... <img src="file://%s"></h3></body></html>' \
                % self.iconProcessIdle)
                
        elif event.key() == Qt.Key_Escape:
            self.close()
            
        #elif event.key() == QKeySequence("Ctrl+E"):
        #    self.leSearch.keyPressEvent(self, event)

    
    def linkClicked(self, url):
        url = toUnicode(url.toString())
        print toUtf8(url)
        
        if url[:6] == 'dolp:/':
            subprocess.Popen(['dolphin', url[6:]])

        elif url[:6] == 'konq:/':
            subprocess.Popen(['konqueror', url[6:]])

        elif url[:9] == 'nepomuk:/':
            #subprocess.Popen(['kioclient', 'exec', url])
            self.leSearch.setText(url)
            self.pendingQuery = True
            self.wvOutput.setHtml('<html><body><h3>Reading... <img src="file://%s"></h3></body></html>' \
                                    % self.iconProcessIdle)

        elif url[:6] == 'prop:/':
            subprocess.Popen(['kioclient', 'openProperties', url[6:]])

        elif url[:7] == 'query:/':
            urlElements = url[7:].split("'")
            if len(urlElements) > 3:
                tmpUrl = urlElements[0] + '"'
                for i in range(1, len(urlElements) - 2):
                    tmpUrl += urlElements[i] + "'"
                tmpUrl += urlElements[-2] + '"'

            else:
                tmpUrl = urlElements[0] + "'" + urlElements[1] + "'"
                
            self.leSearch.setText(tmpUrl)
            self.pendingQuery = True
            self.wvOutput.setHtml('<html><body><h3>Searching... <img src="file://%s"></h3></body></html>' \
                                    % self.iconProcessIdle)

        elif url[:8] == 'remove:/':
            reply = QMessageBox.question(self, '%s - remove resource' % PROGRAM_NAME, "Really delete this resource?", QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
            if reply == QMessageBox.Yes:
                resource = Nepomuk.Resource(url[8:])
                resource.remove()
                self.pendingQuery = True
                self.wvOutput.setHtml('<html><body><h3>Searching... <img src="file://%s"></h3></body></html>' \
                                        % self.iconProcessIdle)
            

        elif url[:8] == 'render:/':
            if url[8:] == 'more':
                renderSize = 0

            elif url[8:] == 'all':
                if len(self.resultData) - self.renderedRows > self.renderSize * 3:
                    reply = QMessageBox.question(self, '%s - render all' % PROGRAM_NAME, "This could be very slow. Continue?", QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
                    if reply != QMessageBox.Yes:
                        return

                renderSize = len(self.resultData)

            else:
                renderSize = -1

            self.leSearch.readOnly = True
            self.wvOutput.setHtml('<html><body><h3>Rendering... <img src="file://%s"></h3></body></html>' \
                                    % self.iconProcessIdle)
            self.wvOutput.repaint()
            self.setCursor(Qt.BusyCursor)
            self.repaint()
            if renderSize >= 0:
                self.wvOutput.setHtml(self.formatResultData([], [], [], 0, renderSize))

            self.setCursor(Qt.ArrowCursor)
            self.leSearch.readOnly = False
            self.repaint()
            
        #elif url[:6] == 'view:/':
            #self.leSearch.setText(url[6:])
            #self.pendingQuery = True
            #self.wvOutput.setHtml('<html><body><h3>Reading... <img src="file://%s"></h3></body></html>' \
                                    #% self.iconProcessIdle)

        else:
            # In KDE we trust.
            subprocess.Popen(["kioclient", "exec", url])

    
    def goBackward(self):
        #print "Go backward"
        if (self.queriesIndex > 0):
            self.queriesIndex -= 1
            
        #print 'Going backward:', self.queriesIndex, self.queries[self.queriesIndex]
        self.leSearch.setText(self.queries[self.queriesIndex])
        self.execQuery(self.queries[self.queriesIndex])

        
    def goForward(self):
        #print "Go forward"
        if (self.queriesIndex < (len(self.queries) - 1)):
            self.queriesIndex += 1
            #print 'Going forward:', self.queriesIndex, self.queries[self.queriesIndex]
            self.leSearch.setText(self.queries[self.queriesIndex])
            self.execQuery(self.queries[self.queriesIndex])
        

    def buildHelp(self, oNsSparqlBuilder):
        commands = '<p><b>Commands</b>:\n<ul>\n'
        for command in oNsSparqlBuilder.commands:
            commands += '<li>%s</li>\n' % command[0]
        commands += '</ul></p>\n'

        shortcuts = '<p><b>Onlologies shorcuts</b>:<ul>\n' + self.htmlTableHeader \
                        % {'border': 0, 'cellpadding': 0}
        for shortcut in oNsSparqlBuilder.shortcuts:
            info = ''
            fmtOntology = shortcut[0]
            if fmtOntology.find('%') >= 0:
                fmtOntology = fmtOntology.replace('%', '')
                info += ' (using percent encoding)'
                                
            if fmtOntology.find('_') >= 0:
                fmtOntology = fmtOntology.replace('_', '')
                info += ' (using optionals to negate)'
              
            shortcuts += '<tr><td><b>%(abr)s</b>, <b>%(shortcut)s</b>:</td><td><em>%(ontology)s</em>%(info)s</td></tr>\n' \
                                % {'abr': shortcut[2], 'shortcut': shortcut[1], 'ontology': fmtOntology, 'info': info}

        shortcuts += self.htmlTableFooter + '</ul></p>\n'

        remarks = "<p><b>Remarks</b>:<br \>\n" \
                    "<ul>\n" \
                    "<li>Query syntax is inspired in Google's search syntax</li>\n" \
                    "<li>Nepoogle do a text search in identifiers, descriptions, tags, fullnames, titles and urls</li>\n" \
                    "<li>Dates and parenthesis are not supported</li>\n" \
                    "<li>You can use regular expressions searching strings</li>\n" \
                    "<li>Nepoogle works with Soprano and don't uses Nepomuk to do queries</li>\n" \
                    "<li>Be cautious, certain ontologies combinations in a same query may offer 0 results</li>\n" \
                    "</ul></p>\n" \

        commandsList = ''
        for command in oNsSparqlBuilder.commands:
            if commandsList != '':
                commandsList += ' | ' + command[0]

            else:
                commandsList += command[0]

        shortcutsList = ''
        for shortcut in oNsSparqlBuilder.shortcuts:
            if shortcutsList != '':
                shortcutsList += ' | ' + shortcut[1]

            else:
                shortcutsList += shortcut[1]

        syntax = "<p><b>The query syntax is</b>:<ul>\n" \
                    "<em>query</em> :== item [[logop] item]... | command | uri<br />\n"\
                    "<br />\n" \
                    "<em>item</em> :== [ontology:][op]text<br />\n" \
                    "<br />\n" \
                    "<em>logop</em> :== and | or<br />\n" \
                    "<em>op</em> :== + | - | < | <= | > | >=<br />\n" \
                    "<br />\n" \
                    "<em>ontology</em> :== [ontitem=]ontitem[->[ontitem=]ontitem]]...<br />\n" \
                    "<em>ontitem</em> :== shortcutontology | shortontology | fullontology<br />\n" \
                    "<em>shortcutontology</em> :== %(shortcuts)s<br />\n" \
                    "<em>shortontology</em> :== prefix:name<br />\n" \
                    "<em>fullontology</em> :== http://url<br />\n" \
                    "<br />\n" \
                    "<em>text</em> :== string | number<br />\n" \
                    "<em>string</em> :== chars | \"chars\" | 'chars'<br />\n" \
                    "<em>number</em> :== 0..9<br />\n" \
                    "<em>chars</em> :== any number of utf-8 characters<br />\n" \
                    "<br />\n" \
                    "<em>command</em> :== instruction[:string]<br />\n" \
                    "<em>instruction</em> :== %(instructions)s\n" \
                    "</ul></p>\n" \
                    % {'shortcuts': shortcutsList, 'instructions': commandsList}

        examples = "<p><b>Examples</b>:\n" \
                    + self.htmlTableHeader % {'border': 1, 'cellpadding': 2} + \
                    "<tr><td><b>query</b></td>\n" \
                        "<td><b>result</b></td></tr>\n" \
                    "<tr><td><em>movie</em></td>\n" \
                        "<td>contains 'movie'</td></tr>\n" \
                    "<tr><td><em>+movie</em></td>\n" \
                        "<td>equals 'movie'</td></tr>\n" \
                    "<tr><td><em>-movie</em></td>\n" \
                        "<td>not contains 'movie'</td></tr>\n" \
                    "<tr><td><em>-dorama +'takeuchi yuuko' 'hiroshi'</em></td>\n" \
                        "<td>not contains 'dorama' and equals 'takeuchi yuuko' and contains 'hiroshi'</td></tr>\n" \
                    "<tr><td><em>movie or hasTag:'takeuchi yuuko'</em></td>\n" \
                        "<td>contains movie or contains tag 'takeuchi yuuko'</td></tr>\n" \
                    "<tr><td><em>hasTag:+movie rating:>=5</em></td>\n" \
                        "<td>tag equals 'movie' and rating >= 5</td></tr>\n" \
                    "<tr><td><em>mimetype:video/x-matroska url:Tiger</em></td>\n" \
                        "<td>mimetype matroska and contains 'Tiger' in url</td></tr>\n" \
                    "<tr><td><em>playcount:0 hastag:corea genre:drama actor:+'Yeong-ae Lee' director:Park</em></td>\n" \
                        "<td>not played movie dramas tagged 'corean' with actress 'Yeong-ae Lee' and with director name contains 'Park'</td></tr>\n" \
                    "<tr><td><em>actor:'Zhang Ziyi' and actor:-'Bingbing Fan'</em></td>\n" \
                        "<td>movies with actress 'Zhang Ziyi' but without actress 'Bingbing Fan'</td></tr>\n" \
                    "<tr><td><em>tvshow:Coupling season:2 episode:4</em></td>\n" \
                        "<td>Episode 4 of Season 2 of Coupling</td></tr>\n" \
                    "<tr><td><em>--tags</em></td>\n" \
                        "<td>all tags</td></tr>\n" \
                    "<tr><td><em>--actors:luppi</em></td>\n" \
                        "<td>all actors containing 'luppi'</td></tr>\n" \
                    + self.htmlTableFooter + \
                    "</p>\n"

        output = "<html>\n  <head>\n"\
                    "<style type=\"text/css\">" \
                    "body {%(body_style)s}\n" \
                    "p {%(p_style)s}\n" \
                    "ul {%(ul_style)s}\n" \
                    "li {%(li_style)s}\n" \
                    "tr {%(tr_style)s}\n" \
                    "</style>\n" \
                    "<title>%(title)s</title>\n    " \
                    "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">" \
                    "\n  </head>\n<body>\n" \
                    "<p><h3>%(program)s's help</h3></p>\n" \
                    "<p><b>%(program)s</b> is a system to query the <em>Nepomuk's database</em>. <b>%(program)s</b> does not search the file system so that only returns results that are pre-collected in <em>Nepomuk's database</em>.</p>\n" \
                    "%(examples)s" \
                    "%(remarks)s" \
                    "%(shortcuts)s" \
                    "%(commands)s" \
                    "%(syntax)s" \
                    "For bugs, sugestions or wishes send a mail to kde@aynoa.net\n" \
                    "%(powered)s</body>\n</html>" \
                    % {'title': 'Querying Nepomuk', \
                        'error': sys.exc_info()[1], \
                        'program': os.path.basename(sys.argv[0]), \
                        'powered': PROGRAM_HTML_POWERED, \
                        'remarks': remarks, \
                        'syntax': syntax, \
                        'shortcuts': shortcuts, \
                        'commands': commands, \
                        'examples': examples, \
                        'body_style': "font-size:small", \
                        'p_style': "font-size:small", \
                        'ul_style': "font-size:small", \
                        'li_style': "font-size:small", \
                        'tr_style': "font-size:small;" \
                        }

        return output

        
    def htmlRenderLink(self, id = 'uri', par1 = '', par2 = ''):

        if id == 'uri':
            title = "title=\"%s\"" % par1
            href = "href=\"%s\"" % par1
            value = par2

        elif id == 'album':
            title = "title=\"album:+\'%s\'\"" % par1
            href = "href=\"query:/album:+\'%s\'\"" % par1
            value = self.htmlLinkSearch

        elif id == 'contact':
            title = "title=\"contact:+\'%s\'\"" % par1
            href = "href=\"query:/contact:+\'%s\'\"" % par1
            value = self.htmlLinkSearch

        elif id == 'ontology':
            title = "title=\"%s:+\'%s\'\"" % (par1, par2)
            href = "href=\"query:/%s:+\'%s\'\"" % (par1, par2)
            value = self.htmlLinkSearch

        elif id == 'performer':
            title = "title=\"performer:+\'%s\'\"" % par1
            href = "href=\"query:/performer:+\'%s\'\"" % par1
            value = self.htmlLinkSearch

        elif id == 'tag':
            title = "title=\"hasTag:+\'%s\'\"" % par1
            href = "href=\"query:/hasTag:+\'%s\'\"" % par1
            value = self.htmlLinkSearch

        # This is an exception.    
        elif id == 'unplugged':
            if par1 == '':
                return "<b>[Unplugged<a title=\"uuid:%s\" href=\"prop:/%s\">%s</a>]</b><em>%s</em>" \
                        % (par2[8:].split('/')[0], \
                            par2[8:].split('/')[0], \
                            self.htmlLinkInfo, \
                            '/' + '/'.join(par2[8:].split('/')[1:]) \
                            )

            else:
                return "<b>[Unplugged<a title=\"uuid:%s\" href=\"prop:/%s\">%s</a>]</b><a title=\"%s\" href=\"%s\"><em>%s</em></a>" \
                        % (par2[8:].split('/')[0], \
                            par2[8:].split('/')[0], \
                            self.htmlLinkInfo, \
                            par1, \
                            par1, \
                            '/' + '/'.join(par2[8:].split('/')[1:]) \
                            )
                        
        elif id == 'url':
            title = "title=\"%s\"" % par1
            href = "href=\"%s\"" % par1
            value = par2
            #TODO: añadir un icono que indique que es un enlace externo.
            
        else:
            return ''

        return "<a %s %s>%s</a>" % (title, href, value)


    def formatResourceInfo(self, uri, knownShortcuts = [], ontologyValueTypes = [], stdout = False):
        query = "select distinct ?x ?ont ?val\n" \
                "where {\n" \
                    "\t<" + uri + "> ?ont ?val .\n"\
                "}\n"

        if stdout:
            print toUtf8(query)
            
        output = self.htmlHeader % {'title': 'Resource viewer'} \
                    + '<b title=\"%(uri)s\">Resource viewer</b><hr>' % {'uri': uri}
        output += self.htmlTableHeader % {'border': 0, 'cellpadding': 3}
        
        data = self.model.executeQuery(query, Soprano.Query.QueryLanguageSparql)
        if data.isValid():
            processedData = []
            images = []
            defaultType = NOCR(Nepomuk.Resource(uri).type())
            while data.next():
                currOnt = NOCR(data["ont"].toString())
                value = toUnicode(data["val"].toString())
                valueType = lvalue(ontologyValueTypes, currOnt.lower().strip(), 0, 1)
                if valueType == 'date':
                    value = formatDate(value[:19])

                elif valueType == 'datetime':
                    value = formatDateTime(value[:19])
                    
                elif valueType == 'datetimep':
                    value = formatDateTime(value[:19], True)

                elif valueType == 'number':
                    value = "%d" % int(float(value))
                    
                #else:
                    #pass
                
                if value[:9] == 'nepomuk:/':
                    resource = Nepomuk.Resource(value)
                    value = ''
                    if resource.hasType(NOC('nao:Tag', True)):
                        #altLabels = QStringListToString(resource.altLabels())
                        ontLabel = '_' + currOnt + '->%nao:identifier'

                    elif resource.hasType(NOC('nco:Contact', True)):
                        #altLabels = QStringListToString(resource.altLabels())
                        ontLabel =  '_' + currOnt + '->nco:fullname'

                    elif resource.hasType(NOC('nfo:Folder', True)):
                        ontLabel = currOnt + '->nfo:fileName'

                    elif resource.hasType(NOC('nmm:MusicAlbum', True)):
                        ontLabel = currOnt + '->nie:title'

                    elif resource.hasType(NOC('rdfs:Resource', True)):
                        ontLabel = ''
                        ext = os.path.splitext(toUnicode(resource.genericLabel()))[1][1:]
                        if ext != '' and ext in QImageReader.supportedImageFormats():
                            if resource.hasProperty(NOC('nie:url')):
                                images += [toUnicode(resource.property(NOC('nie:url')).toString())]

                    else:
                        value = toUnicode(resource.type())

                    if value == '':
                        shorcut = lvalue(knownShortcuts, ontLabel, 0, 1)
                        if shorcut == None:
                            shorcut = ontLabel

                        value = '<!--' + toUnicode(resource.genericLabel()) + '-->' \
                                    + self.htmlRenderLink('uri', resource.uri(), resource.genericLabel())
                        if ontLabel != '':
                            value += ' ' + self.htmlRenderLink('ontology', shorcut, resource.genericLabel())
                        
                elif currOnt == '22-rdf-syntax-ns:type':
                    value = NOCR(value)
                    if value == defaultType:
                        value = '<em>' + value + '</em>'
 
                elif currOnt == 'nie:url':
                    url = fromPercentEncoding(value)
                    ext = os.path.splitext(url)[1][1:]
                    if ext != '' and ext in QImageReader.supportedImageFormats():
                        if fileExists(value):
                            images += [value]
                        
                    value = ''
                    if url[:7] == 'file://':
                        value += url
                        if (os.path.exists(url[7:]) or os.path.islink(url[7:])):
                            value += ' ' + self.htmlLinkSystemRun % (url)
                            value += ' ' + self.htmlLinkOpenLocation % (os.path.dirname(url))

                    elif url[:8] == 'filex://':
                        value += self.htmlRenderLink('unplugged', \
                                                        '', \
                                                        url \
                                                    )
#                                            url[8:].split('/')[0], \
#                                            '/' + '/'.join(url[8:].split('/')[1:]))

                elif currOnt == 'nmm:genre':
                    value = value + ' ' + self.htmlRenderLink('ontology', 'genre', value)

                else:
                    if fileExists(value):
                        ext = os.path.splitext(value)[1][1:]
                        if ext != '' and ext in QImageReader.supportedImageFormats():
                            images += [value]

                        if value[:7] != 'file://':
                            value = 'file://' + value
                            
                        value = '<a title=\"%(url)s\" href=\"%(url)s\">%(name)s</a>' \
                                    % {'url': value, 'name': os.path.basename(value)}

                    else:
                        # No es un fichero así que añadimos los links si hay urls.
                        value = addLinksToText(value)

                if value != '':
                    processedData += [[currOnt, ontologyToHuman(currOnt), value]]

        text = ''
        if len(processedData) > 0:
            processedData = sorted(processedData, key=lambda row: row[1] + row[2])
            oldOnt = ''
            for row in processedData:
                if (oldOnt != row[1]):
                    if text != '':
                        text += '</td></tr>\n'
                        
                    text += '<tr><td valign=\"top\" width=\"100px\">' \
                            '<b title=\"%s\">%s</b>:</td><td>%s' \
                                % (row[0], row[1], row[2])
                    oldOnt = row[1]

                else:
                    text += ', ' + row[2]
                        
        if text == '':
            output += '<p>No data found for the uri %s.</p>\n' % uri

        else:
            output += text

        # Reverse resources.
        query = "select ?uri ?ont\n" \
                "   where { " \
                "       ?uri ?ont <%s> ." \
                "}" \
                "order by ?ont" % uri
        data = self.model.executeQuery(query, Soprano.Query.QueryLanguageSparql)
        reverseResources = []
        if data.isValid():
            while data.next():
                uri = toUnicode(data["uri"].toString())
                res = Nepomuk.Resource(uri)
                val = fromPercentEncoding(toUnicode(res.genericLabel()))
                reverseResources += [[uri, NOCR(data["ont"].toString()), val]]

            tmpOutput = ''
            if len(reverseResources) > 0:
                reverseResources = sorted(reverseResources, key=lambda revRes: revRes[1] + revRes[2])
                oldOnt = ''
                for item in reverseResources:
                    if oldOnt != item[1]:
                        if tmpOutput != '':
                            output += tmpOutput.replace('</a><', '</a>, <')
                            tmpOutput = ''
                            
                        output += '<tr><td valign=\"top\" width=\"100px\"><b title=\"%s\">%s</b>:</td><td>' \
                                    % (item[1], ontologyToHuman(item[1], True))
                        oldOnt = item[1]

                    tmpOutput += '<!-- ' + item[2] + '-->' \
                                    + self.htmlRenderLink('uri', item[0], item[2]) # \
                                    #+ ' ' + self.htmlRenderLink('ontology', item[1], item[2])

                tmpOutput = tmpOutput.replace('</a><', '</a>, <')

            output += tmpOutput + '</td></tr>\n'

        output += self.htmlTableFooter + "<hr>\n"
        
        # Resource images.
        if len(images) > 0:
            for image in images:
                if image[:7] != 'file://':
                    image = 'file://' + image
                    
                output += '<img title=\"%(url)s\" src=\"%(url)s\"><br />\n' \
                            % {'url': image}

            output += '<hr>\n'

        output += self.htmlFooter
        
        if stdout:
            print toUtf8(output)
            
        return output
            
        
    def formatResultData(self, data = [], structure = [], knownShortcuts = [], \
                            queryTime = None, renderSize = None, stdout = False):
        htmlQueryTime = time.time()

        if data == []:
            data = self.resultData

        if structure == []:
            structure = self.resultStructure

        if knownShortcuts == []:
            knownShortcuts = self.sparql.shortcuts

        if queryTime == None:
            queryTime = self.resultTime
                
        result = self.htmlHeader % {'title': 'Querying Nepomuk'}
        result += self.htmlTableHeader % {'border': 1, 'cellpadding': 3}

        if ((renderSize == None) or (renderSize == 0)):
            renderSize = self.renderSize

        # Evitar que queden unos pocos registros.
        if ((len(data) - self.renderedRows - renderSize) <= (self.renderSize / 3)):
            renderSize = len(data) - self.renderedRows
        
        resources = []
        if self.renderedRows <= 0:
            text = ''

        else:
            text = self.renderedCache
            
        for i in range(self.renderedRows, min(len(data), renderSize + self.renderedRows)):
            item = data[i]
            text += '<tr>'
                        
            resRow = []
            for subItem in item:
                if subItem == '':
                    continue
                  
                if (subItem[:7] == 'file://'):
                    subItem = fromPercentEncoding(subItem)
                    resRow += [['file', subItem]]

                elif ((subItem[:7] == 'http://') or (subItem[:6] == 'ftp://') or (subItem[:8] == 'https://')):
                    subItem = fromPercentEncoding(subItem)
                    resRow += [['url', subItem]]

                elif (subItem[:8] == 'filex://'):
                    subItem = fromPercentEncoding(subItem)
                    resRow += [['filex', subItem]]

                #elif (subItem[0] == '[') and (subItem[-1] == ']'):
                    #resRow += [['type', subItem]]

                elif (subItem[:9] == 'nepomuk:/'):
                    resRow += [['nepomuk', subItem]]
                    resourceID = subItem

                elif (subItem[:6] == 'ont://'):
                    resRow = [item]
                    break

                else:
                    resRow += [['', subItem]]

            resources += [resRow]
            
        itemType = ''
        for row in resources:
            links = ''
            textData = ''
            queryLink = ''
            nepomukResource = None
            for i in range(0, len(row)):
                item = row[i]

                # URI.
                if item[0] == 'nepomuk':
                    nepomukResource = Nepomuk.Resource(item[1])
                    itemType = toUnicode(nepomukResource.resourceType().toString().split('#')[1])
                    
                    htmlstr = self.htmlLinkProperties % (item[1])
                    htmlstr += ' ' + self.htmlLinkRemove % (item[1])
                    if links == '':
                        links = htmlstr

                    else:
                        links = htmlstr + links

                # File URL.
                elif item[0] == 'file':
                    links += ' ' + self.htmlLinkDolphin % (item[1])
                    links += ' ' + self.htmlLinkKonqueror % (item[1])

                    if textData != '':
                        textData += '<br />'

                    if (os.path.exists(item[1][7:]) or os.path.islink(item[1][7:])):
                        textData += self.htmlRenderLink("uri", nepomukResource.uri(), os.path.basename(item[1]))
                        textData += ' ' + self.htmlLinkSystemRun % (item[1])
                        textData += ' ' + self.htmlLinkOpenLocation % (os.path.dirname(item[1]))

                    else:
                        textData += self.htmlRenderLink('url', item[1], os.path.basename(item[1]))

                # Filex URL.
                elif item[0] == 'filex':
                    if textData != '':
                        textData += '<br />'


                    textData += self.htmlRenderLink('unplugged', \
                                                        nepomukResource.uri(), \
                                                        item[1]\
                                                    )
                    #                        item[1][8:].split('/')[0], \
                    #                        '/' + '/'.join(item[1][8:].split('/')[1:]))

                # URL.
                elif item[0] == 'url':
                    if textData != '':
                        textData += '<br />'

                    textData += self.htmlRenderLink('url', item[1], os.path.basename(item[1]))
                        
                # Special, to control properties.
                elif item[0][:6] == 'ont://':
                    itemType = ontologyToHuman(item[0][6:])
                    if textData != '':
                        textData += '<br />'

                    textData += item[1] + ' ' + self.htmlRenderLink('ontology', item[0][6:], item[1])

                else:
                    if queryLink == '':
                        queryLink = item[1]

                    if textData != '':
                        textData += '<br />'

                    itemTypeLower = itemType.lower()
                    if itemTypeLower == 'contact':
                        # En las queries genéricas la columna se llama url.
                        #TODO: mal hack, esto es confuso, mirar de arreglarlo.
                        if structure[i] == 'fullname' or structure[i] == 'url':
                            textData += self.htmlRenderLink('uri', nepomukResource.uri(), item[1]) \
                                            + ' ' + self.htmlRenderLink('contact', item[1])
                            links += ' ' + self.htmlLinkDolphin % (nepomukResource.uri())
                            links += ' ' + self.htmlLinkKonqueror % (nepomukResource.uri())

                    elif itemTypeLower == 'tag':
                        # En las queries genéricas la columna se llama url.
                        #TODO: mal hack, esto es confuso, mirar de arreglarlo.
                        if structure[i] == 'prefLabel' or structure[i] == 'url':
                            textData += self.htmlRenderLink('uri', nepomukResource.uri(), item[1]) \
                                            + ' ' + self.htmlRenderLink('tag', item[1])
                                            
                        else:
                            #TODO: mal hack, esto es confuso, mirar de arreglarlo.
                            if structure[i] == 'title':
                                textData += '%s: %s' % (ontologyToHuman('nie:altLabel'), item[1])
                                
                            else:
                                textData += '%s: %s' % (ontologyToHuman(structure[i]), item[1])

                    else:
                        textData += '<em>' + item[1] + '</em>'

            if nepomukResource == None:
                if itemType == '':
                    itemType = 'Property'

            #else:
            #    itemType = toUnicode(nepomukResource.resourceType().toString().split('#')[1])

            if itemType == '':
                itemType = 'unknown'

            else:
                if queryLink != '':
                    itemTypeLower = itemType.lower()
                    if itemTypeLower == 'musicalbum':
                        textData = textData.replace('<em>', '').replace('</em>', '')
                        textData = self.htmlRenderLink('uri', nepomukResource.uri(), textData) \
                                    + ' ' + self.htmlRenderLink('album', textData)
                        
                        query = 'select distinct ?performer ?name\n' \
                                'where {\n' \
                                    '   ?uri nmm:musicAlbum <%s> .\n' \
                                    '   ?uri nmm:performer ?performer . ?performer nco:fullname ?name\n' \
                                '}\n' \
                                'order by ?name' \
                                % nepomukResource.uri()
                        performers = self.model.executeQuery(query, Soprano.Query.QueryLanguageSparql)
                        additionalData = ''
                        if performers.isValid():
                            while performers.next():
                                if additionalData != '':
                                    additionalData += ', '
                                    
                                additionalData += self.htmlRenderLink('uri', performers["performer"].toString(), performers["name"].toString()) \
                                                    + ' ' + self.htmlRenderLink('performer', performers["name"].toString())
                                                    
                        if additionalData != '':
                            additionalData = '<br />%s: ' % _('Performer') + additionalData

                        textData += additionalData
                        
                        links += ' ' + self.htmlLinkDolphin % (nepomukResource.uri())
                        links += ' ' + self.htmlLinkKonqueror % (nepomukResource.uri())
                    
                    elif itemTypeLower == 'musicpiece':
                        # Title:, disc and track before title.
                        trackNumber = nepomukResource.property(NOC('nmm:trackNumber')).toString()
                        if len(trackNumber) < 2:
                            trackNumber = '0' + trackNumber
                            
                        discNumber = nepomukResource.property(NOC('nmm:setNumber')).toString()
                        if discNumber != '':
                            discNumber += 'x'
                            
                        textData = textData.replace('<br /><em>', '<br />%s: <em>%s%s - ' % (_('Title'), discNumber, trackNumber))
                        
                        # Album title.
                        tmpUri = nepomukResource.property(NOC('nmm:musicAlbum')).toString()
                        query = 'select distinct ?title\n' \
                            'where {\n' \
                                '   <%s> nie:title ?title .\n' \
                            '}\n' \
                            % tmpUri
                        queryResultSet = self.model.executeQuery(query, Soprano.Query.QueryLanguageSparql)
                        additionalData = ''
                        if queryResultSet.isValid():
                            # I known, there is only one possible record but...
                            while queryResultSet.next():
                                if additionalData != '':
                                    additionalData += ', '

                                additionalData += self.htmlRenderLink('uri', tmpUri, queryResultSet["title"].toString()) \
                                                    + ' ' + self.htmlRenderLink('album', queryResultSet["title"].toString())

                        if additionalData != '':
                            #trackNumber = nepomukResource.property(NOC('nmm:trackNumber')).toString()
                            #textData += '<br />%s: %s, %s %s' % \
                            #                (_('Album'), additionalData, _('track'), trackNumber)
                            textData += '<br />%s: ' % (_('Album')) + additionalData
                            #discNumber = nepomukResource.property(NOC('nmm:setNumber')).toString()
                            #if discNumber != '':
                            #    textData += ', %s %s' % (_('disc'), discNumber)

                        # Performer.
                        tmpUri = nepomukResource.property(NOC('nmm:performer')).toString()
                        query = 'select distinct ?fullname\n' \
                            'where {\n' \
                                '   <%s> nco:fullname ?fullname .\n' \
                            '}\n' \
                            % tmpUri
                        queryResultSet = self.model.executeQuery(query, Soprano.Query.QueryLanguageSparql)
                        additionalData = ''
                        if queryResultSet.isValid():
                            # I known, there is only one possible record but...
                            while queryResultSet.next():
                                if additionalData != '':
                                    additionalData += ', '

                                additionalData += self.htmlRenderLink('uri', tmpUri, queryResultSet["fullname"].toString()) \
                                                    + ' ' + self.htmlRenderLink('contact', queryResultSet["fullname"].toString())

                        if additionalData != '':
                            textData += '<br />%s: ' % _('Performer') + additionalData

                    elif itemTypeLower == 'tvshow':
                        additionalData = "<br />Episode: <em>%sx%02d</em> " \
                                            % (toUnicode(nepomukResource.property(NOC('nmm:season', True)).toString()), \
                                                int(toUnicode(nepomukResource.property(NOC('nmm:episodeNumber')).toString())))
                        textData = textData.replace('<br />', additionalData)


            text += '<td>' + textData + '</td><td>' + itemType + '</td>'
            text += self.htmlLinks % links
            text += '</tr>\n'

            if stdout:
                print toUtf8(text)

            self.renderedRows += 1

        self.renderedCache = text
        if self.renderedRows < len(data):
            text += '<td><a href="render:/more">%s more</a>, <a href="render:/all">all records</a></td>' \
                    '<td>%s of %s records</td>' \
                        % (self.renderSize, self.renderedRows, len(data))
            text += self.htmlLinks % ''

        
        text += self.htmlTableFooter
        text += self.htmlTime % {'records': len(data), 'seconds': queryTime, 'sechtml': time.time() - htmlQueryTime}
        if stdout:
            print toUtf8(text)

        result += text + self.htmlFooter
        if stdout:
            print toUtf8(result)
    
        return result

        
    def execQuery(self, searchString = ''):
        self.leSearch.readOnly = True
        self.setCursor(Qt.BusyCursor)
        self.repaint()

        self.renderedRows = 0
        self.renderedCache = ''
        
        self.resultData = []
        self.resultStructure = []
        self.resultTime = None
       
        self.sparql = nsSparqlBuilder()
        self.sparql.stdoutQuery = sys.stdout.isatty()
        self.sparql.columns = '?x0 AS ?id ' + self.sparql.columns

        if searchString == '':
            searchString = toUnicode(self.leSearch.text().trimmed().toUtf8())
            textTyped = True

        else:
            textTyped = False

        #if True:
        try:
          
            if searchString[:9] == 'nepomuk:/':
                output = self.formatResourceInfo(searchString, self.sparql.shortcuts, self.sparql.ontologyTypes)
              
            elif searchString != '':
                self.resultData, self.resultStructure, self.resultTime = self.sparql.executeQuery(self.sparql.buildQuery(searchString))
                output = self.formatResultData()

            else:
                raise Exception('Please, type something.')

            if (textTyped or (self.queriesIndex < 0)):
                if ((self.queriesIndex + 1) < len(self.queries)):
                    self.queries = self.queries[:self.queriesIndex + 1]

                if (self.queries != []):
                    if (self.queries[self.queriesIndex] != searchString):
                        self.queries += [searchString]
                        self.queriesIndex = len(self.queries) - 1

                else:
                    self.queries = [searchString]
                    self.queriesIndex = 0
                
        #try:
        #    pass
        
        except:
            msgError = "%s" % sys.exc_info()[1]
            if msgError == 'help':
                output = self.buildHelp(self.sparql)

            elif msgError == 'quit':
                quit()

            else:
                output = "<html>\n  <head>\n    <title>%(title)s</title>\n    " \
                            "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">" \
                            "\n  </head>\n<body><b>error:</b> %(error)s" \
                            "%(powered)s</body>\n</html>" \
                            % {'title': 'Querying Nepomuk', \
                                'error': sys.exc_info()[1], \
                                'powered': PROGRAM_HTML_POWERED \
                                }

        self.pendingQuery = False
        self.wvOutput.setHtml(output)
        self.setCursor(Qt.ArrowCursor)
        self.leSearch.readOnly = False
        self.repaint()
        
  
def buildHelp():
    print "%(name)s %(version)s (%(date)s)\n" \
              % {'name': PROGRAM_NAME, 'version': PROGRAM_VERSION_VERSION, 'date': PROGRAM_VERSION_DATE}
              
    print "Usage: %s command | query\n" \
          "\n" \
          "commands:\n" \
          "  --help\t--  Shows this help\n" \
          "  --gui\t\t--  Console mode\n" \
          "  --stdout\t--  Prints SPARQL query to stdout (default in gui mode)\n" \
          "\n" \
          "query:\n" \
          "  Consult the help in gui mode\n" \
          % PROGRAM_NAME
  
  
def formatResultData(data = [], structure = [], queryTime = 0, stdout = False):
    text = ''
    for row in data:
        line = ''
        for column in row:
            if column == '':
                continue

            if column[:9] == 'nepomuk:/':
                continue
            
            if line != '':
                line += ', '
                
            line += toUtf8(column)

        if line != '':
            text += line + '\n'

    return text

    
def main(args):

    #appName = PROGRAM_NAME
    #catalog = PROGRAM_NAME
    #programName = ki18n(PROGRAM_NAME)
    #version = PROGRAM_VERSION_VERSION
    #description = ki18n("An alternate search engine for Nepomuk inspired in Google search syntax.")
    #license = KAboutData.License_GPL
    #copyright = ki18n("(C) 2011 Ignacio Serantes")
    #text = ki18n("A search engine for Nepomuk.")
    #homePage = "http://kde-apps.org/content/show.php/Nepoogle?content=145505"
    #bugEmail = "kde@aynoa.net"

    #aboutData = KAboutData(appName, catalog, programName, version,
                            #description, license, copyright, text, homePage,
                            #bugEmail)

    #KCmdLineArgs.init(sys.argv, aboutData)

    #options = KCmdLineOptions()
    #options.add("--help", ki18n("this help"))
    #options.add("--gui", ki18n("force gui in console mode"))
    #options.add("--stdout", ki18n("force stdout in console mode"))
    #options.add("--nostdout", ki18n("force no stdout in gui mode"))
    #KCmdLineArgs.addCmdLineOptions(options)
    
    gui = not sys.stdout.isatty()
    stdout = None
    parameters = toUnicode('')
    for i in range(1, len(args)):
        parameter = toUnicode(args[i].strip())
        if parameter.lower() == '--help':
            buildHelp()
            quit()
        
        elif parameter.lower() == '--gui':
            gui = True
            continue
        
        elif parameter.lower() == '--stdout':
            if stdout == None:
                stdout = True
            continue
        
        elif parameter.find(' ') >= 0:
            j = parameter.rfind(':')
            if j >= 0:
                parameter = parameter[:j+1] + '"' + parameter[j+1:] + '"'
                
            else:
                parameter = '"' + parameter + '"'
            
        parameters += parameter + ' '
        
    if stdout == None:
        stdout == gui

    if gui:
        #app = KApplication()
        #window = Nepoogle(parameters.strip())
        #window.show()

        #if parameters != '':
        #    window.execQuery()
        
        app = QApplication(args)
        nepoogle = Nepoogle(None, parameters.strip())
        nepoogle.show()
        nepoogle.repaint()

        if parameters != '':
            nepoogle.execQuery()

        sys.exit(app.exec_())

    else:

        o = nsSparqlBuilder()
        o.stdoutQuery = stdout
        o.columns = '?x0 AS ?id ' + o.columns

        #if True:
        try:
            if parameters != '':
                data, structure, time = o.executeQuery(o.buildQuery(parameters))
                output = formatResultData(data, structure, time)

            else:
                raise Exception('Please, type something.')

        #try:
        #    pass

        except:
            msgError = "%s" % sys.exc_info()[1]
            if msgError == 'help':
                output = buildHelp()

            else:
                output = "%(title)s\n" \
                            "\nerror: %(error)s\n" \
                            "\nPowered by %(name)s %(version)s (%(date)s)" \
                            % {'title': 'Querying Nepomuk', \
                                'error': sys.exc_info()[1], \
                                'name': PROGRAM_NAME, \
                                'version': PROGRAM_VERSION_VERSION, \
                                'date': PROGRAM_VERSION_DATE \
                                }

        print toUtf8(output)
        

if __name__=="__main__":
    os.putenv("DISPLAY", ":0")
    main(sys.argv)
