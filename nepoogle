#!/usr/bin/env python
# -*- coding: utf-8 -*-

#***************************************************************************
#*   nepoogle - a Nepomuk's search engine inspired in Google search syntax *
#*                                                                         *
#*   Copyright                                                             *
#*   (C) 2011 Ignacio Serantes <kde@aynoa.net>                             *
#*                                                                         *
#*   This program is free software; you can redistribute it and/or modify  *
#*   it under the terms of the GNU General Public License as published by  *
#*   the Free Software Foundation; either version 2 of the License, or     *
#*   (at your option) any later version.                                   *
#*                                                                         *
#*   This program is distributed in the hope that it will be useful,       *
#*   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
#*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
#*   GNU General Public License for more details.                          *
#*                                                                         *
#*   You should have received a copy of the GNU General Public License     *
#*   along with this program; if not, write to the                         *
#*   Free Software Foundation, Inc.,                                       *
#*   51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.         *
#***************************************************************************

import datetime, gettext, os, re, subprocess, sys, time

from PyQt4.QtCore import *
from PyKDE4.nepomuk import *
from PyKDE4.soprano import *

from PyQt4.QtGui import *
from PyQt4.QtWebKit import *
from PyKDE4.kdeui import *
#from PyKDE4.kdecore import ki18n, i18n, KCmdLineArgs, KAboutData
#from PyKDE4.kdeui import KApplication, KXmlGuiWindow, KStandardAction, KAction, KIcon
#from PyKDE4.kdecore import *

#_BUG: carácter ' de Singin' in the Rain
#_BUG: fallan las búsquedas con el carácter ":"
#_BUG: encoding incorrecto
#_BUG: sample rate se visualiza en notación científica
#_BUG: error: [Errno 5] Input/output error la llamar al programa sin la consola
#_BUG: uri incorrecta en el link al album de la pieza musical
#_TODO: visualizar las fechas correctamente
#_TODO: los links a visor deben funcionar con los discos desconectados
#_BUG: Modifiers "+" and "-" were not working filtering commands.
#_BUG: Duplicate entries, one for rdf:type of resourcer, when self.caseInsensitiveSort = True
#_TODO: sort case insensitive, columna lower(?x) AS ?sort
#_TODO: añadir totales y tiempos en consola
#_TODO: añadir al resource viewer los siguientes links: . << < > >>

#BUG: BUG001 -> negation without a shorcut is failing.
#TODO: extraer tipo y label de la propia db. Esto está actualmente hardcoded y
#repartido entre la función ontologyToHuman y la propiedad cSparqlBuilder.ontologyTypes.
#Ejemplo:
#SELECT *
#WHERE {
    #nao:altLabel rdfs:range ?range
    #OPTIONAL { nao:altLabel rdfs:label ?label . }
#}
#Resultado: <http://www.w3.org/2000/01/rdf-schema#Literal>, "alternative label"
#TODO: bif:lower(?x) in ('x', 'y', 'z')
#TODO: musicpiece debe de incluir el intérprete
#TODO: añadir más información al contacto en la vista de resultados
#TODO: añadir soporte a nepomuk:/ en consola
#TODO: visor de álbum debería incluir los intérpretes/creadores del mismo y la carátula
#TODO: mostrar estrellas en el rating por coherencia
#TODO: count()
#select count(?x0) as ?cuantos
#where {
#{
#query a contar
#}
#}
#TODO: implementar cache al moverse de atrás adelante (ojo con la vista por partes)
#TODO: configuración externa
#TODO: multilenguage
#TODO: paréntesis
#TODO: editor: gestionar comentarios, rating y tags.
#TODO: soporte para la modificación de comentarios
#TODO: soporte para la modificación del rating
#TODO: soporte para la gestión de tags. Idea:
#       Más usados: los 10 tags más usados listados alfabéticamente.
#       Usados: los últimos tags usados, debajo los últimos que has usado.
#       Alfabética: la vista normal.
#       Botón de eliminar todos.
#TODO: añadir soporte a --connect, --disconnect, --daemonize y moverlos a Nepoogle

PROGRAM_URL = sys.argv[0]
PROGRAM_NAME = os.path.basename(sys.argv[0])
PROGRAM_BASENAME = os.path.splitext(PROGRAM_NAME)[0]
PROGRAM_PATH = os.path.dirname(os.path.abspath(sys.argv[0]))
PROGRAM_VERSION_VERSION = 'v0.7'
PROGRAM_VERSION_DATE = '2011-11-xx'
PROGRAM_AUTHOR_NAME = 'Ignacio Serantes'
PROGRAM_AUTHOR_EMAIL = 'kde@aynoa.net'
PROGRAM_HTML_POWERED = "<br />--<br /><b>Powered by</b> <em>%(name)s</em> <b>%(version)s</b> released (%(date)s)" \
                        % {'name': PROGRAM_NAME, \
                            'version': PROGRAM_VERSION_VERSION, \
                            'date': PROGRAM_VERSION_DATE \
                            }

gettext.bindtextdomain(PROGRAM_NAME, '') #'/path/to/my/language/directory')
gettext.textdomain(PROGRAM_NAME)
_ = gettext.gettext
#gettext.translation(PROGRAM_NAME, languages=['es']).install()

#IF BUILD
#INCLUDE lfunctions.py 
#ELSE
from lfunctions import *
#ENDIF

#IF BUILD
#INCLUDE clsparql.py
#ELSE
from clsparql import *
#ENDIF

#IF BUILD
#INCLUDE cldataformat.py
#ELSE
from cldataformat import *
#ENDIF

#class nCompleter(QCompleter):

    #separator = " "
    
    #def __init__(self, *args):

        #super(nCompleter, self).__init__(*args)
        
        #model = QStringListModel()
        #wordList = [ \
                    #u"and", u"or",\
                    #u"actor:", \
                    #u"album", \
                    #u"creator", \
                    #u"director:", \
                    #u"genre", \
                    #u"hasTag:", \
                    #u"name:", \
                    #u"performer", \
                    #u"preflabel:", \
                    #u"rating:", \
                    #u"tag:", \
                    #u"title:", \
                    #u"url:", \
                    #u"writer:", \
                    #u"--help", \
                    #u"--allActors", \
                    #u"--allAlbums", \
                    ##u"--allCreators", \
                    #u"--allDirectors", \
                    #u"--allGenres", \
                    #u"--allPerformers", \
                    #u"--allTags", \
                    #u"--allWriters" \
                    #]

        #model.setStringList(wordList)
        #self.setModel(model)
        #self.setCaseSensitivity(Qt.CaseInsensitive);
        #self.setModelSorting(QCompleter.CaseSensitivelySortedModel)
        
        ##self.setCompletionMode(QCompleter.PopupCompletion)
        ##self.setCompletionMode(QCompleter.InlineCompletion)

        
    #def pathFromIndex(self, index):
        #path = QCompleter.pathFromIndex(self, index)

        #lst = str(self.widget().text()).split(self.separator)
        #if len(lst) > 1:
            #path = '%s%s%s' % (self.separator.join(lst[:-1]), self.separator, path)

        #return path

        
    #def splitPath(self, path):
        #path = str(path.split(self.separator)[-1]).lstrip(self.separator)
        #return [path]


#
# cWebView class
#
class cWebView(QWebView):

    def __init__(self, *args):
        super(cWebView, self).__init__(*args)
      
        #self.setContextMenuPolicy(Qt.PreventContextMenu)
        #self.setContextMenuPolicy(Qt.CustomContextMenu)
        self.page().setLinkDelegationPolicy(QWebPage.DelegateAllLinks)
        self.page().setForwardUnsupportedContent(True)


    #def acceptNavigationRequest(frame, request, navigationType):
        #print "acceptNavigationRequest", frame, request, navigationType
    
    
    #def createWindow(self, type):
        #print "createWindow", type

        
    #def customContextMenuRequested(self, pos):
    #    print 'customContextMenuRequested'

        
    #def contextMenuEvent(self, event):
    #    if False:
    #        self.popMenu = QMenu(self)
    #        self.popMenu.addAction("Open in New Window", self, SLOT(self.openLinkInNewWindow))
    #        self.popMenu.addSeparator()

    #    else:
    #        super(cWebView, self).contextMenuEvent(event)


    #def openLinkInNewWindow(self, url):
    #    print url

    #def triggerPageAction(action, checked):
    #    print checked, action
        
#
# Nepoogle class
#
class Nepoogle(QWidget):
    cache = []
    model = None
    navigationData = []
    pendingQuery = False
    #queries = []
    queriesIndex = -1
    renderedCache = ''
    renderedRows = 0
    renderSize = 50
    resultData = []
    resultStructure = []
    resultTime = None
    sparql = None
    verboseMode = False
    warningsList = []

    iconDelete = KIconLoader().iconPath('edit-delete', KIconLoader.NoGroup)
    iconDocumentInfo = KIconLoader().iconPath('documentinfo', KIconLoader.NoGroup)
    iconDocumentProp = KIconLoader().iconPath('document-properties', KIconLoader.NoGroup)
    iconFileManager = KIconLoader().iconPath('system-file-manager', KIconLoader.NoGroup)
    iconKonqueror = KIconLoader().iconPath('konqueror', KIconLoader.NoGroup)
    iconNavigateFirst = KIconLoader().iconPath('go-first', KIconLoader.NoGroup)
    iconNavigateLast = KIconLoader().iconPath('go-last', KIconLoader.NoGroup)
    iconNavigateNext = KIconLoader().iconPath('go-next', KIconLoader.NoGroup)
    iconNavigatePrevious = KIconLoader().iconPath('go-previous', KIconLoader.NoGroup)
    iconProcessIdle = KIconLoader().iconPath('process-idle', KIconLoader.NoGroup)
    iconSystemRun = KIconLoader().iconPath('system-run', KIconLoader.NoGroup)
    iconSystemSearch = KIconLoader().iconPath('system-search', KIconLoader.NoGroup)

    #htmlFooter = "%s</body>\n</html>\n" % PROGRAM_HTML_POWERED
    #htmlHeader = "<html>\n" \
                    #"<head>\n" \
                    #"<style type=\"text/css\">" \
                    #"    body {%(body_style)s}\n" \
                    #"    tr {%(tr_style)s}\n" \
                    #"    p {%(p_style)s}\n" \
                    #"</style>\n" \
                    #% {'body_style': "font-size:small;", \
                        #'p_style': "font-size:small;", \
                        #'tr_style': "font-size:small;" \
                        #} \
                    #+ "<title>%(title)s</title>\n" \
                        #"    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n" \
                        #"%(script)s\n" \
                        #"</head>\n<body>\n"
    #htmlImgStyle = "align=\"bottom\" border=\"0\" hspace=\"0\" vspace=\"0\" style=\"width: 14px; height: 14px;\""
    #htmlNavigateStyle  = "align=\"center\" border=\"0\" hspace=\"0\" vspace=\"0\" style=\"width: 20px; height: 20px;\""
    #htmlTableHeader = "<table style=\"text-align:left; width: 100%%;\" " \
                        #"border=\"%(border)s\" cellpadding=\"%(cellpadding)s\" cellspacing=\"0\">" \
                        #"<tbody>\n"
    #htmlTableFooter = "</tbody></table>\n"
    #htmlTime = "<br />\n%(records)s records found in %(seconds)f seconds. \
                #HTML visualization builded in %(sechtml)s seconds."
                

    #htmlLinkDolphin = "<a href=\"dolp:/%s\"><img %s title=\"%s\" src=\"file://%s\"></a>" \
                        #% ('%s', htmlImgStyle, 'open with Dolphin', iconFileManager)
    #htmlLinkInfo = "<img %s src=\"file://%s\">" % (htmlImgStyle, iconDocumentInfo)
    #htmlLinkKonqueror = "<a href=\"konq:/%s\"><img %s title=\"%s\" src=\"file://%s\"></a>" \
                        #% ('%s', htmlImgStyle, 'open with Konqueror', iconKonqueror)
    #htmlLinkNavigateFirst = "<a \"Go %(to)s\" href=\"navigate:/%(to)s\"><img %(style)s title=\"Go %(to)s\" src=\"file://%(icon)s\"></a>" \
                            #% {"to": "first", "style": htmlNavigateStyle, "icon": iconNavigateFirst}
    #htmlLinkNavigateLast = "<a \"Go %(to)s\" href=\"navigate:/%(to)s\"><img %(style)s title=\"Go %(to)s\" src=\"file://%(icon)s\"></a>" \
                            #% {"to": "last", "style": htmlNavigateStyle, "icon": iconNavigateLast}
    #htmlLinkNavigatePrevious = "<a \"Go %(to)s\" href=\"navigate:/%(to)s\"><img %(style)s title=\"Go %(to)s\" src=\"file://%(icon)s\"></a>" \
                            #% {"to": "previous", "style": htmlNavigateStyle, "icon": iconNavigatePrevious}
    #htmlLinkNavigateNext = "<a \"Go %(to)s\" href=\"navigate:/%(to)s\"><img %(style)s title=\"Go %(to)s\" src=\"file://%(icon)s\"></a>" \
                            #% {"to": "next", "style": htmlNavigateStyle, "icon": iconNavigateNext}
    #htmlLinkOpenLocation = "<a href=\"%s\"><img %s title=\"%s\" src=\"file://%s\"></a>" \
                            #% ('%s', htmlImgStyle, 'open location', iconFileManager)
    #htmlLinkProperties = "<a href=\"prop:/%s\"><img %s title=\"%s\" src=\"file://%s\"></a>" \
                            #% ('%s', htmlImgStyle, 'properties', iconDocumentInfo)
    #htmlLinkRemove = "<a href=\"remove:/%s\"><img %s title=\"%s\" src=\"file://%s\"></a>" \
                            #% ('%s', htmlImgStyle, 'remove resource', iconDelete)
    #htmlLinks = "<td width=\"65px\">%s</td>"
    #htmlLinkSearch = "<img %s src=\"file://%s\">" % (htmlImgStyle, iconSystemSearch)
    #htmlLinkSystemRun = "<a href=\"%s\"><img %s title=\"%s\" src=\"file://%s\"></a>" \
                            #% ('%s', htmlImgStyle, 'system run', iconSystemRun)


    def __init__(self, parent = None, searchString = '', verboseMode = False):
        super(Nepoogle, self).__init__(parent)

        self.verboseMode = verboseMode

        self.model = Nepomuk.ResourceManager.instance().mainModel()

        #self.setGeometry(300, 300, 250, 150)
        #self.setWindowTitle(os.path.basename(sys.argv[0]))
        self.setWindowTitle(PROGRAM_NAME)
        #self.setWindowIcon(QIcon('icon.png'))
        self.setWindowIcon(QIcon(KIconLoader().loadIcon('nepomuk',  KIconLoader.NoGroup,  KIconLoader.SizeSmall)))

        self.leSearch = QLineEdit(self)
        #self.leSearch.setCompleter(nCompleter())
        self.leSearch.selectOnEntry = True

        self.pbBackward = QPushButton(self)
        self.pbBackward.setIcon(QIcon(KIconLoader().loadIcon('go-previous',  KIconLoader.NoGroup,  KIconLoader.SizeSmall)))
        #self.pbBackward.setGeometry(QRect(self.leSearch.height(), self.leSearch.height(), self.leSearch.height(), self.leSearch.height()))
        self.connect(self.pbBackward, SIGNAL("clicked()"), self.goBackward)
    
        self.pbForward = QPushButton(self)
        self.pbForward.setIcon(QIcon(KIconLoader().loadIcon('go-next',  KIconLoader.NoGroup,  KIconLoader.SizeSmall)))
        #self.pbForward.setGeometry(QRect(self.leSearch.height(), self.leSearch.height(), self.leSearch.height(), self.leSearch.height()))
        self.connect(self.pbForward, SIGNAL("clicked()"), self.goForward)

        self.hbl = QHBoxLayout()
        self.hbl.setSpacing(1)
        self.hbl.addWidget(self.pbBackward)
        self.hbl.addWidget(self.pbForward)
        self.hbl.addWidget(self.leSearch)

        self.wvOutput = cWebView(self)
        self.connect(self.wvOutput, SIGNAL("linkClicked(const QUrl&)"), self.linkClicked)
        self.connect(self.wvOutput, SIGNAL("loadStarted()"), self.loadStarted)
        self.connect(self.wvOutput, SIGNAL("loadFinished(bool)"), self.loadFinished)
        self.connect(self.wvOutput, SIGNAL("loadProgress(int)"), self.loadProgress)
        #self.connect(self.wvOutput.page(), SIGNAL("customContextMenuRequested(const QPoint&)"), self.customContextMenuRequested)

        # This action has no changes.
        self.actionOpenLink = self.wvOutput.pageAction(QWebPage.OpenLink)
        self.connect(self.actionOpenLink, SIGNAL("triggered(bool)"), self.openLink)

        # DownloadLinkToDisk renamed and used as OpenLinkInNewWindow
        self.actionDownloadLinkToDisk = self.wvOutput.pageAction(QWebPage.DownloadLinkToDisk)
        self.actionDownloadLinkToDisk.setText(_("Open in New Window"))
        #self.connect(self.actionDownloadLinkToDisk, SIGNAL("triggered(bool)"), self.downloadLinkToDisk)

        # Invisible OpenLinkInNewWindow.
        self.actionOpenLinkInNewWindow = self.wvOutput.pageAction(QWebPage.OpenLinkInNewWindow)
        self.actionOpenLinkInNewWindow.setVisible(False)
        #self.connect(self.actionOpenLinkInNewWindow, SIGNAL("triggered(bool)"), self.openLinkInNewWindow)

        # Invisible OpenImageInNewWindow.
        self.actionOpenImageInNewWindow = self.wvOutput.pageAction(QWebPage.OpenImageInNewWindow)
        self.actionOpenImageInNewWindow.setVisible(False)

        self.connect(self.wvOutput.page(), SIGNAL("downloadRequested(const QNetworkRequest&)"), self.downloadRequested)
        self.connect(self.wvOutput.page(), SIGNAL("unsupportedContent(QNetworkReply*)"), self.unsupportedContent)
        self.wvOutput.page().setForwardUnsupportedContent(True)
        
        self.grid = QGridLayout()
        self.grid.setSpacing(10)
        #self.grid.addWidget(self.leSearch, 1, 1)
        self.grid.addLayout(self.hbl, 1, 1)
        self.grid.addWidget(self.wvOutput, 2, 1, 5, 1)

        self.setLayout(self.grid)

        self.resize(680, 510)
        if searchString == '':
            self.leSearch.setText(toUnicode('Type search here'))

        else:
            self.leSearch.setText(searchString)

        self.leSearch.setSelection(0,999)
        self.leSearch.setFocus()
        
        if searchString == '':
            self.execQuery('--help')


    #def downloadLinkToDisk(self, checked):
    #    print "downloadLinkToDisk", checked
    #    pass


    def downloadRequested(self, request):
        #print "downloadRequested", request.url().toString()
        url = toUnicode(request.url().toString())
        if url != "":
            if url[:9] == 'nepomuk:/':
                pass

            elif url[:7] == 'query:/':
                url = url[7:]

            elif url[:6] == "file:/":
                subprocess.Popen(["kioclient", "exec", url])
                url = ''

            else:
                url = ''

            if url != '':
                print toUtf8(url)
                subprocess.Popen([PROGRAM_URL, "--gui", toUtf8(url)])

        
    def unsupportedContent(self, request):
        #print "downloadRequested", request.url().toString()
        QMessageBox.warning(self, '%s - %s' % (PROGRAM_NAME, _("warning")), "Option not available yet.")


    def openLink(self, checked):
        #print "openLink", checked, toUtf8(self.wvOutput.page().currentFrame().requestedUrl())
        url = toUnicode(self.wvOutput.page().currentFrame().requestedUrl())
        if url.toString() != "":
            self.linkClicked(url, True)

        
    def openLinkInNewWindow(self, checked):
        #print "openLinkInNewWindow", checked, toUtf8(self.wvOutput.page().currentFrame().requestedUrl())
        url = toUnicode(self.wvOutput.page().currentFrame().requestedUrl().toString())
        if url != "":
            print toUtf8(url)
            if url[:9] == 'nepomuk:/':
                pass

            elif url[:7] == 'query:/':
                url = url[7:]

            elif url[:6] == "file:/":
                subprocess.Popen(["kioclient", "exec", url])
                url = ''

            else:
                url = ''

            if url != '':
                subprocess.Popen([PROGRAM_URL, "--gui", toUtf8(url)])

        
    def loadFinished(self, ok):
        #print 'loadFinished:', ok
        self.repaint()
        if self.pendingQuery:
            self.execQuery()

            
    def loadProgress(self, progress):
        #print 'loadProgress:', progress
        pass

        
    def loadStarted(self):
        #print 'loadStarted', self.wvOutput.url().toString()
        pass


    def keyPressEvent(self, event):
        if event.key() == Qt.Key_Return or event.key() == Qt.Key_Enter:
            self.pendingQuery = True
            self.wvOutput.setHtml('<html><body><h3>Searching... <img src="file://%s"></h3></body></html>' \
                % self.iconProcessIdle)
                
        elif event.key() == Qt.Key_Escape:
            self.close()
            
        #elif event.key() == QKeySequence("Ctrl+E"):
        #    self.leSearch.keyPressEvent(self, event)

    
    def linkClicked(self, url, forceExec = False, overwriteQueriesList = False):
        url = toUnicode(url.toString())
        print toUtf8(url)
        
        if url[:6] == 'dolp:/':
            subprocess.Popen(['dolphin', url[6:]])

        elif url[:6] == 'konq:/':
            subprocess.Popen(['konqueror', url[6:]])

        elif url[:10] == 'navigate:/':
            if ((self.navigationData == []) or (len(self.navigationData) < 2)):
                return True

            idx = lindex(self.navigationData, self.leSearch.text(), 0)
            if idx != None:
                navigateTo = url[10:].lower()
                if navigateTo == "first":
                    idx = 0

                elif navigateTo == "previous":
                    if idx > 0:
                        idx -= 1

                elif navigateTo == "next":
                    if idx < len(self.navigationData) - 1:
                        idx += 1

                elif navigateTo == "last":
                    idx = len(self.navigationData) - 1

                #else:
                    #pass

                self.linkClicked(QUrl(self.navigationData[idx][0]), True, False)
            
        elif url[:9] == 'nepomuk:/':
            #subprocess.Popen(['kioclient', 'exec', url])
            self.leSearch.setText(url)
            if not overwriteQueriesList:
                self.pendingQuery = True
                
            self.wvOutput.setHtml('<html><body><h3>Reading... <img src="file://%s"></h3></body></html>' \
                                    % self.iconProcessIdle)
            if forceExec:
                self.execQuery("", overwriteQueriesList)
                self.pendingQuery = False

        elif url[:6] == 'prop:/':
            subprocess.Popen(['kioclient', 'openProperties', url[6:]])

        elif url[:7] == 'query:/':
            urlElements = url[7:].split("'")
            if len(urlElements) >= 3:
                tmpUrl = urlElements[0] + '"'
                for i in range(1, len(urlElements) - 2):
                    tmpUrl += urlElements[i] + "'"
                tmpUrl += urlElements[-2] + '"'

            elif len(urlElements) == 2:
                tmpUrl = urlElements[0] + "'" + urlElements[1] + "'"

            elif len(urlElements) == 1:
                tmpUrl = "'" + urlElements[0] + "'"
                
            else:
                pass
                
            self.leSearch.setText(tmpUrl)
            self.pendingQuery = True
            self.wvOutput.setHtml('<html><body><h3>Searching... <img src="file://%s"></h3></body></html>' \
                                    % self.iconProcessIdle)
            if forceExec:
                self.execQuery()
                self.pendingQuery = False

        elif url[:8] == 'remove:/':
            reply = QMessageBox.question(self, '%s - remove resource' % PROGRAM_NAME, "Really delete this resource?", QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
            if reply == QMessageBox.Yes:
                resource = Nepomuk.Resource(url[8:])
                resource.remove()
                self.pendingQuery = True
                self.wvOutput.setHtml('<html><body><h3>Searching... <img src="file://%s"></h3></body></html>' \
                                        % self.iconProcessIdle)
                if forceExec:
                    self.execQuery()
                    self.pendingQuery = False

        elif url[:8] == 'render:/':
            if url[8:] == 'more':
                renderSize = 0

            elif url[8:] == 'all':
                if len(self.resultData) - self.renderedRows > self.renderSize * 3:
                    reply = QMessageBox.question(self, '%s - render all' % PROGRAM_NAME, "This could be very slow. Continue?", QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
                    if reply != QMessageBox.Yes:
                        return

                renderSize = len(self.resultData)

            else:
                renderSize = -1

            self.leSearch.readOnly = True
            self.wvOutput.setHtml('<html><body><h3>Rendering... <img src="file://%s"></h3></body></html>' \
                                    % self.iconProcessIdle)
            self.wvOutput.repaint()
            self.setCursor(Qt.BusyCursor)
            self.repaint()
            if renderSize >= 0:
                self.wvOutput.setHtml(self.formatResultData([], [], [], 0, renderSize))

            self.setCursor(Qt.ArrowCursor)
            self.leSearch.readOnly = False
            self.repaint()

        elif url[:9] == 'render2:/':
            self.leSearch.readOnly = True
            self.wvOutput.setHtml('<html><body><h3>Rendering... <img src="file://%s"></h3></body></html>' \
                                    % self.iconProcessIdle)
            self.wvOutput.repaint()
            self.setCursor(Qt.BusyCursor)
            self.repaint()
            self.wvOutput.setHtml(self.cache[self.queriesIndex].formatAsHtml(url[9:]))

            self.setCursor(Qt.ArrowCursor)
            self.leSearch.readOnly = False
            self.repaint()

        #elif url[:6] == 'view:/':
            #self.leSearch.setText(url[6:])
            #self.pendingQuery = True
            #self.wvOutput.setHtml('<html><body><h3>Reading... <img src="file://%s"></h3></body></html>' \
                                    #% self.iconProcessIdle)

        else:
            # In KDE we trust.
            subprocess.Popen(["kioclient", "exec", url])

    
    def goBackward(self):
        #print "Go backward"
        if (self.queriesIndex > 0):
            self.queriesIndex -= 1

            #print 'Going backward:', self.queriesIndex, self.queries[self.queriesIndex]
            #self.leSearch.setText(self.queries[self.queriesIndex])
            #self.execQuery(self.queries[self.queriesIndex])
            #if len(self.resultData) <= 1:
            #    self.navigationData = []

        if self.leSearch.setText != self.cache[self.queriesIndex].searchString:
            self.setCursor(Qt.BusyCursor)
            self.leSearch.setText(self.cache[self.queriesIndex].searchString)
            self.pendingQuery = False
            self.wvOutput.setHtml(self.cache[self.queriesIndex].formatAsHtml())
            self.setCursor(Qt.ArrowCursor)
            self.leSearch.readOnly = False
            self.repaint()
            self.navigationData = self.cache[self.queriesIndex].data
            
        
    def goForward(self):
        #print "Go forward"
        #if (self.queriesIndex < (len(self.queries) - 1)):
            #self.queriesIndex += 1
            #print 'Going forward:', self.queriesIndex, self.queries[self.queriesIndex]
            #self.leSearch.setText(self.queries[self.queriesIndex])
            #self.execQuery(self.queries[self.queriesIndex])

        if (self.queriesIndex < (len(self.cache) - 1)):
            self.queriesIndex += 1
            self.setCursor(Qt.BusyCursor)
            self.leSearch.setText(self.cache[self.queriesIndex].searchString)
            self.pendingQuery = False
            self.wvOutput.setHtml(self.cache[self.queriesIndex].formatAsHtml())
            self.setCursor(Qt.ArrowCursor)
            self.leSearch.readOnly = False
            self.repaint()
            self.navigationData = self.cache[self.queriesIndex].data
        

    def buildHelp(self, oSparqlBuilder):
        commands = '<p><b>Commands</b>:\n<ul>\n'
        for command in oSparqlBuilder.commands:
            commands += '<li>%s</li>\n' % command[0]
        commands += '</ul></p>\n'

        shortcuts = '<p><b>Onlologies shorcuts</b>:<ul>\n' + self.htmlTableHeader \
                        % {'border': 0, 'cellpadding': 0}
        for shortcut in oSparqlBuilder.shortcuts:
            info = ''
            fmtOntology = shortcut[0]
            if fmtOntology.find('%') >= 0:
                fmtOntology = fmtOntology.replace('%', '')
                info += ' (using percent encoding)'
                                
            if fmtOntology.find('_') >= 0:
                fmtOntology = fmtOntology.replace('_', '')
                info += ' (using optionals to negate)'
              
            shortcuts += '<tr><td><b>%(abr)s</b>, <b>%(shortcut)s</b>:</td><td><em>%(ontology)s</em>%(info)s</td></tr>\n' \
                                % {'abr': shortcut[2], 'shortcut': shortcut[1], 'ontology': fmtOntology, 'info': info}

        shortcuts += self.htmlTableFooter + '</ul></p>\n'

        remarks = "<p><b>Remarks</b>:<br \>\n" \
                    "<ul>\n" \
                    "<li>Query syntax is inspired in Google's search syntax</li>\n" \
                    "<li>Nepoogle do a text search in identifiers, descriptions, tags, fullnames, titles and urls</li>\n" \
                    "<li>Dates and parenthesis are not supported</li>\n" \
                    "<li>You can use regular expressions searching strings</li>\n" \
                    "<li>Nepoogle works with Soprano and don't uses Nepomuk to do queries</li>\n" \
                    "<li>Be cautious, certain ontologies combinations in a same query may offer 0 results</li>\n" \
                    "</ul></p>\n" \

        commandsList = ''
        for command in oSparqlBuilder.commands:
            if commandsList != '':
                commandsList += ' | ' + command[0]

            else:
                commandsList += command[0]

        shortcutsList = ''
        for shortcut in oSparqlBuilder.shortcuts:
            if shortcutsList != '':
                shortcutsList += ' | ' + shortcut[1]

            else:
                shortcutsList += shortcut[1]

        syntax = "<p><b>The query syntax is</b>:<ul>\n" \
                    "<em>query</em> :== item [[logop] item]... | command | uri<br />\n"\
                    "<br />\n" \
                    "<em>item</em> :== [ontology:][op]text<br />\n" \
                    "<br />\n" \
                    "<em>logop</em> :== and | or<br />\n" \
                    "<em>op</em> :== + | - | < | <= | > | >=<br />\n" \
                    "<br />\n" \
                    "<em>ontology</em> :== [ontitem=]ontitem[->[ontitem=]ontitem]]...<br />\n" \
                    "<em>ontitem</em> :== shortcutontology | shortontology | fullontology<br />\n" \
                    "<em>shortcutontology</em> :== %(shortcuts)s<br />\n" \
                    "<em>shortontology</em> :== prefix:name<br />\n" \
                    "<em>fullontology</em> :== http://url<br />\n" \
                    "<br />\n" \
                    "<em>text</em> :== string | number<br />\n" \
                    "<em>string</em> :== chars | \"chars\" | 'chars'<br />\n" \
                    "<em>number</em> :== 0..9<br />\n" \
                    "<em>chars</em> :== any number of utf-8 characters<br />\n" \
                    "<br />\n" \
                    "<em>command</em> :== instruction[:string]<br />\n" \
                    "<em>instruction</em> :== %(instructions)s\n" \
                    "</ul></p>\n" \
                    % {'shortcuts': shortcutsList, 'instructions': commandsList}

        examples = "<p><b>Examples</b>:\n" \
                    + self.htmlTableHeader % {'border': 1, 'cellpadding': 2} + \
                    "<tr><td><b>query</b></td>\n" \
                        "<td><b>result</b></td></tr>\n" \
                    "<tr><td><em>movie</em></td>\n" \
                        "<td>contains word 'movie'</td></tr>\n" \
                    "<tr><td><em>+movie</em></td>\n" \
                        "<td>equals word 'movie'</td></tr>\n" \
                    "<tr><td><em>-movie</em></td>\n" \
                        "<td>not contains word 'movie'</td></tr>\n" \
                    "<tr><td><em>hastag:-dorama +'takeuchi yuuko' 'hiroshi'</em></td>\n" \
                        "<td>not tagged as 'dorama' and equals 'takeuchi yuuko' and contains 'hiroshi'</td></tr>\n" \
                    "<tr><td><em>movie or hasTag:'takeuchi yuuko'</em></td>\n" \
                        "<td>contains movie or tagged 'takeuchi yuuko'</td></tr>\n" \
                    "<tr><td><em>hasTag:+movie rating:>=5</em></td>\n" \
                        "<td>tagged exactly 'movie' and rating >= 5</td></tr>\n" \
                    "<tr><td><em>url:\"^file:///media\" mimetype:image mimetype:-image/jpeg</em></td>\n" \
                        "<td>all image files, except jpegs, located in /media</td></tr>\n" \
                    "<tr><td><em>mimetype:image/png height:>=1200 width:>=1600</em></td>\n" \
                        "<td>all pngs with a resolution great or equal to 1600x1200</td></tr>\n" \
                    "<tr><td><em>playcount:0 hastag:corea genre:drama actor:+'Yeong-ae Lee' director:Park</em></td>\n" \
                        "<td>not played movie dramas tagged 'corea' with actress 'Yeong-ae Lee' and with director name contains 'Park'</td></tr>\n" \
                    "<tr><td><em>actor:'Zhang Ziyi' and actor:-'Bingbing Fan'</em></td>\n" \
                        "<td>movies with actress 'Zhang Ziyi' but without actress 'Bingbing Fan'</td></tr>\n" \
                    "<tr><td><em>tvshow:Coupling season:2 episode:4</em></td>\n" \
                        "<td>Episode 4 of Season 2 of Coupling</td></tr>\n" \
                    "<tr><td><em>--tags</em></td>\n" \
                        "<td>all tags</td></tr>\n" \
                    "<tr><td><em>--actors:luppi</em></td>\n" \
                        "<td>all actors containing 'luppi'</td></tr>\n" \
                    + self.htmlTableFooter + \
                    "</p>\n"

        output = "<html>\n  <head>\n"\
                    "<style type=\"text/css\">" \
                    "body {%(body_style)s}\n" \
                    "p {%(p_style)s}\n" \
                    "ul {%(ul_style)s}\n" \
                    "li {%(li_style)s}\n" \
                    "tr {%(tr_style)s}\n" \
                    "</style>\n" \
                    "<title>%(title)s</title>\n    " \
                    "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">" \
                    "\n  </head>\n<body>\n" \
                    "<p><h3>%(program)s's help</h3></p>\n" \
                    "<p><b>%(program)s</b> is a system to query the <em>Nepomuk's database</em>. <b>%(program)s</b> does not search the file system so that only returns results that are pre-collected in <em>Nepomuk's database</em>.</p>\n" \
                    "%(examples)s" \
                    "%(remarks)s" \
                    "%(shortcuts)s" \
                    "%(commands)s" \
                    "%(syntax)s" \
                    "For bugs, suggestions or wishes send a mail to kde@aynoa.net\n" \
                    "%(powered)s</body>\n</html>" \
                    % {'title': 'Querying Nepomuk', \
                        'error': sys.exc_info()[1], \
                        'program': os.path.basename(sys.argv[0]), \
                        'powered': PROGRAM_HTML_POWERED, \
                        'remarks': remarks, \
                        'syntax': syntax, \
                        'shortcuts': shortcuts, \
                        'commands': commands, \
                        'examples': examples, \
                        'body_style': "font-size:small", \
                        'p_style': "font-size:small", \
                        'ul_style': "font-size:small", \
                        'li_style': "font-size:small", \
                        'tr_style': "font-size:small;" \
                        }

        return output

        
    def htmlRenderLink(self, id = 'uri', par1 = '', par2 = ''):

        if id == 'uri':
            title = "title=\"%s\"" % par1
            href = "href=\"%s\"" % par1
            value = par2

        elif id == 'album':
            title = "title=\"album:+\'%s\'\"" % par1
            href = "href=\"query:/album:+\'%s\'\"" % par1
            value = self.htmlLinkSearch

        elif id == 'contact':
            title = "title=\"contact:+\'%s\'\"" % par1
            href = "href=\"query:/contact:+\'%s\'\"" % par1
            value = self.htmlLinkSearch

        elif id == 'navigator':
            return "%s%s%s%s" % (self.htmlLinkNavigateFirst, \
                                    self.htmlLinkNavigatePrevious, \
                                    self.htmlLinkNavigateNext, \
                                    self.htmlLinkNavigateLast)

        elif id == 'ontology':
            title = "title=\"%s:+\'%s\'\"" % (par1, par2)
            href = "href=\"query:/%s:+\'%s\'\"" % (par1, par2)
            value = self.htmlLinkSearch

        elif id == 'performer':
            title = "title=\"performer:+\'%s\'\"" % par1
            href = "href=\"query:/performer:+\'%s\'\"" % par1
            value = self.htmlLinkSearch

        elif id == 'tag':
            title = "title=\"hasTag:+\'%s\'\"" % par1
            href = "href=\"query:/hasTag:+\'%s\'\"" % par1
            value = self.htmlLinkSearch

        # This is an exception.    
        elif id == 'unplugged':
            if par1 == '':
                return "<b>[Unplugged<a title=\"uuid:%s\" href=\"prop:/%s\">%s</a>]</b><em>%s</em>" \
                        % (par2[8:].split('/')[0], \
                            par2[8:].split('/')[0], \
                            self.htmlLinkInfo, \
                            '/' + '/'.join(par2[8:].split('/')[1:]) \
                            )

            else:
                return "<b>[Unplugged<a title=\"uuid:%s\" href=\"prop:/%s\">%s</a>]</b><a title=\"%s\" href=\"%s\"><em>%s</em></a>" \
                        % (par2[8:].split('/')[0], \
                            par2[8:].split('/')[0], \
                            self.htmlLinkInfo, \
                            par1, \
                            par1, \
                            '/' + '/'.join(par2[8:].split('/')[1:]) \
                            )
                        
        elif id == 'url':
            title = "title=\"%s\"" % par1
            href = "href=\"%s\"" % par1
            value = par2
            #TODO: añadir un icono que indique que es un enlace externo.
            
        else:
            return ''

        return "<a %s %s>%s</a>" % (title, href, value)


    #def formatResourceInfo(self, uri, knownShortcuts = [], ontologyValueTypes = [], stdout = False):
        #query = "select distinct ?x ?ont ?val\n" \
                #"where {\n" \
                    #"\t<" + uri + "> ?ont ?val .\n"\
                #"}\n"

        #if stdout:
            #print toUtf8(query)

        #script = ""
        ##script = \
        ##        "<script type=\"text/javascript\">function getObjectXY(o){var x,y;c=o;if(o.offsetParent){x=y=0;do{x+=o.offsetLeft;if(o.style.borderLeftWidth!='')x+=parseInt(o.style.borderLeftWidth);else o.style.borderLeftWidth='0px';y+=o.offsetTop;if(o.style.borderTopWidth!='')y+=parseInt(o.style.borderTopWidth);else o.style.borderTopWidth='0px';}while(o=o.offsetParent);}return [x-parseInt(c.style.borderLeftWidth),y-parseInt(c.style.borderLeftWidth)];}function retInt(s,f){if(typeof s=='number')return s;var result=s.indexOf(f);return parseInt(s.substring(0,(result!=-1)?result:s.length));}function getMouseXY(e){var x=0,y=0;if(!e)e=window.event;if(e.pageX||e.pageY){x=e.pageX;y=e.pageY;}else if(e.clientX||e.clientY){x=e.clientX+document.body.scrollLeft+document.documentElement.scrollLeft;y=e.clientY+document.body.scrollTop+document.documentElement.scrollTop;}return [x,y];}function mouseWheel(){var s=this;var w=function(e,o,d){};s.wheelHandler=function(e){var d=0;if(!e)e=window.event;if(e.wheelDelta)d=e.wheelDelta/120;else if(e.detail)d=-e.detail/3;if(e.preventDefault)e.preventDefault();e.returnValue=false;if(d)w(e,this,d);};s.init=function(o,c){if(o.addEventListener)o.addEventListener('DOMMouseScroll',this.wheelHandler,false);o.onmousewheel=this.wheelHandler;w=c;};this.setCallback=function(c){w=c;}}function viewer(args){var s=this;s.outerFrame=null;var i=null,imageSource=null,parent=null,replace=null,preLoader=null;var frame=['400px','400px',true];var zoomFactor='10%';var m='300%';i=args['image']?args['image']:null;imageSource=args['imageSource']?args['imageSource']:null;parent=args['parent']?args['parent']:null;replace=args['replace']?args['replace']:null;preLoader=args['preLoader']?args['preLoader']:null;frame=args['frame']?args['frame']:['400px','400px',true];zoomFactor=args['zoomFactor']?args['zoomFactor']:'10%';m=args['maxZoom']?args['maxZoom']:'300%';s.frameElement=s.f=null;var oW,oH,l=0;var lm=null,sp=5;var mo=null;s.getFrameDimension=function(){return [s.f.clientWidth,s.f.clientHeight];};s.setDimension=function(w,h){i.width=Math.round(w);i.height=Math.round(h);};s.getDimension=function(){return [i.width,i.height];};s.setPosition=function(x,y){i.style.left=(Math.round(x)+'px');i.style.top=(Math.round(y)+'px');};s.getPosition=function(){return [retInt(i.style.left,'px'),retInt(i.style.top,'px')];};s.setMouseCursor=function(){var d=s.getDimension();var fd=s.getFrameDimension();var c='crosshair';if(d[0]>fd[0]&&d[1]>fd[1])c='move';else if(d[0]>fd[0])c='e-resize';else if(d[1]>fd[1])c='n-resize';i.style.cursor=c;};s.maxZoomCheck=function(w,h){if(typeof w=='undefined'||typeof h=='undefined'){var t=s.getDimension();w=t[0],h=t[1];}if(typeof m=='number'){return((w/oW)>m||(h/oH)>m);}else if(typeof m=='object'){return(w>m[0]||h>m[1]);}};s.fitToFrame=function(w,h){if(typeof w=='undefined'||typeof h=='undefined'){w=oW,h=oH;}var fd=s.getFrameDimension(),nW,nH;nW=fd[0];nH=Math.round((nW*h)/w);if(nH>(fd[1])){nH=fd[1];nW=Math.round((nH*w)/h);}return [nW,nH];};s.getZoomLevel=function(){return l;};s.zoomTo=function(nl,x,y){var fd=s.getFrameDimension();if(nl<0||x<0||y<0||x>=fd[0]||y>=fd[1])return false;var d=s.fitToFrame(oW,oH);for(var n=nl;n>0;n--)d[0]*=zoomFactor,d[1]*=zoomFactor;var cW=i.width,cH=i.height;var p=s.getPosition();p[0]-=((x-p[0])*((d[0]/cW)-1)),p[1]-=((y-p[1])*((d[1]/cH)-1));p=s.centerImage(d[0],d[1],p[0],p[1]);if(!s.maxZoomCheck(d[0],d[1])){l=nl;s.setDimension(d[0],d[1]);s.setPosition(p[0],p[1]);s.setMouseCursor();}else return false;return true;};s.centerImage=function(w,h,x,y){if(typeof w=='undefined'||typeof h=='undefined'){var t=s.getDimension();w=t[0],h=t[1];};if(typeof x=='undefined'||typeof y=='undefined'){var t=s.getPosition();x=t[0],y=t[1];}var fd=s.getFrameDimension();if(w<=fd[0])x=Math.round((fd[0] - w)/2);if(h<=fd[1])y=Math.round((fd[1] - h)/2);if(w>fd[0]){if(x>0)x=0;else if((x+w)<fd[0])x=fd[0]-w;}if(h>fd[1]){if(y>0)y=0;else if((y+h)<fd[1])y=fd[1]-h;}return [x,y];};s.relativeToAbsolute=function(x,y){if(x<0||y<0||x>=s.f.clientWidth||y>=s.f.clientHeight)return null;return [x-retInt(i.style.left,'px'),y-retInt(i.style.top,'px')];};s.reset=function(){var d=s.fitToFrame(oW,oH);var p=s.centerImage(d[0],d[1],0,0);s.setDimension(d[0],d[1]);s.setPosition(p[0],p[1]);l=0;};s.moveBy=function(x,y){var p=s.getPosition();p=s.centerImage(i.width,i.height,p[0]+x,p[1]+y);s.setPosition(p[0],p[1]);};s.hide=function(){if(s.outerFrame)s.outerFrame.style.display='none';else s.f.style.display='none';};s.show=function(){if(s.outerFrame)s.outerFrame.style.display='block';else s.f.style.display='block';};s.onload=null;s.onmousewheel=function(e,o,direction){s.f.focus();if(!e)e=window.event,e.returnValue=false;else if(e.preventDefault)e.preventDefault();if((l+direction)>=0){var mp=getMouseXY(e);var fp=getObjectXY(s.f);s.zoomTo(l+direction,mp[0]-fp[0],mp[1]-fp[1]);}};s.onmousemove=function(e){if(!e)e=window.event,e.returnValue=false;else if(e.preventDefault)e.preventDefault();var mp=getMouseXY(e);var p=s.getPosition();p[0]+=(mp[0]-lm[0]),p[1]+=(mp[1]-lm[1]);lm=mp;p=s.centerImage(i.width,i.height,p[0],p[1]);s.setPosition(p[0],p[1]);};s.onmouseup_or_out=function(e){if(!e)e=window.event,e.returnValue=false;else if(e.preventDefault)e.preventDefault();i.onmousemove=i.onmouseup=i.onmouseout=null;i.onmousedown=s.onmousedown;};s.onmousedown=function(e){s.f.focus();if(!e)e=window.event,e.returnValue=false;else if(e.preventDefault)e.preventDefault();lm=getMouseXY(e);i.onmousemove=s.onmousemove;i.onmouseup=i.onmouseout=s.onmouseup_or_out;};s.onkeypress=function(e){var k;if(window.event)e=window.event,k=e.keyCode,e.returnValue=false;else if(e.which)k=e.which,e.preventDefault();k=String.fromCharCode(k);var p=s.getPosition();var LEFT='a',UP='w',RIGHT='d',DOWN='s',CENTER_IMAGE='c',ZOOMIN='=',ZOOMOUT='-';if(k==LEFT)p[0]+=sp;else if(k==UP)p[1]+=sp;else if(k==RIGHT)p[0]-=sp;else if(k==DOWN)p[1]-=sp;else if(k==CENTER_IMAGE||k=='C')s.reset();else if(k==ZOOMIN||k=='+'||k=='x'||k=='X')s.zoomTo(l+1,s.f.clientWidth/2,s.f.clientHeight/2);else if((k==ZOOMOUT||k=='z'||k=='Z')&&l>0)s.zoomTo(l-1,s.f.clientWidth/2,s.f.clientHeight/2);if(k==LEFT||k==UP||k==RIGHT||k==DOWN){p=s.centerImage(i.width,i.height,p[0],p[1]);s.setPosition(p[0],p[1]);sp+=2;}};s.onkeyup=function(e){sp=5;};s.setZoomProp=function(nZF,nMZ){if(nZF==null)zoomFactor=10;zoomFactor=1+retInt(nZF,'%')/100;if(typeof nMZ=='string')m=retInt(nMZ,'%')/100;else if(typeof nMZ=='object'&&nMZ!=null){m[0]=retInt(nMZ[0],'px');m[1]=retInt(nMZ[1],'px');}else m='300%';};s.setFrameProp=function(newFrameProp){s.f.style.width=newFrameProp[0];s.f.style.height=newFrameProp[1];};s.initImage=function(){i.style.maxWidth=i.style.width=i.style.maxHeight=i.style.height=null;oW=i.width;oH=i.height;var d=s.fitToFrame(oW,oH);s.setDimension(d[0],d[1]);if(frame[2]==true)s.f.style.width=(Math.round(d[0])+'px');if(frame[3]==true)s.f.style.height=(Math.round(d[1])+'px');var p=s.centerImage(d[0],d[1],0,0);s.setPosition(p[0],p[1]);s.setMouseCursor();mo=new mouseWheel();mo.init(i,s.onmousewheel);i.onmousedown=s.onmousedown;s.f.onkeypress=s.onkeypress;s.f.onkeyup=s.onkeyup;if(viewer.onload!=null)viewer.onload(s);if(s.onload!=null)s.onload();};s.preInitImage=function(){if(preLoader!=null){i.style.left=((s.f.clientWidth-i.width)/2)+'px';i.style.top=((s.f.clientHeight-i.height)/2)+'px';}i.onload=s.initImage;i.src=imageSource;};s.setNewImage=function(newImageSource,newPreLoader){if(typeof newImageSource=='undefined')return;imageSource=newImageSource;if(typeof newPreLoader!=='undefined')preLoader=newPreLoader;if(preLoader!=null){i.onload=s.preInitImage;i.src=preLoader;return;}i.onload=s.initImage;i.src=imageSource;};s.setZoomProp(zoomFactor,m);s.frameElement=s.f=document.createElement('div');s.f.style.width=frame[0];s.f.style.height=frame[1];s.f.style.border=\"0px solid #000\";s.f.style.margin=\"0px\";s.f.style.padding=\"0px\";s.f.style.overflow=\"hidden\";s.f.style.position=\"relative\";s.f.style.zIndex=2;s.f.tabIndex=1;if(i!=null){if(parent !=null){i.parentNode.removeChild(i);parent.appendChild(s.f);}else if(replace !=null){i.parentNode.removeChild(i);replace.parentNode.replaceChild(s.f,replace);}else i.parentNode.replaceChild(s.f,i);i.style.margin=i.style.padding=\"0\";i.style.borderWidth=\"0px\";i.style.position='absolute';i.style.zIndex=3;s.f.appendChild(i);if(imageSource!=null)s.preInitImage();else s.initImage();}else{if(parent!=null)parent.appendChild(s.f);else if(replace!=null)replace.parentNode.replaceChild(s.f,replace);i=document.createElement('img');i.style.position='absolute';i.style.zIndex=3;s.f.appendChild(i);s.setNewImage(imageSource);}};viewer.onload=null;</script>"
        ##imageViewer = "<img title=\"%(url)s\" src=\"%(url)s\" style=\"width:400px;\" "\
        ##                "onLoad=\"new viewer({image: this, frame: ['400px','250px']});\"/>"
        #output = self.htmlHeader % {'title': 'Resource viewer', 'script': script} \
                    #+ '<b title=\"%(uri)s\"><h2>Resource viewer</b>&nbsp;&nbsp;%(navigator)s</h2><hr>' \
                        #% {'uri': uri, "navigator": self.htmlRenderLink("navigator")}
        #output += self.htmlTableHeader % {'border': 0, 'cellpadding': 3}
        
        #data = self.model.executeQuery(query, Soprano.Query.QueryLanguageSparql)
        #if data.isValid():
            #processedData = []
            #images = []
            #defaultType = NOCR(Nepomuk.Resource(uri).type())
            #while data.next():
                #currOnt = NOCR(data["ont"].toString())
                #value = toUnicode(data["val"].toString())
                #valueType = lvalue(ontologyValueTypes, currOnt.lower().strip(), 0, 1)
                #if valueType == 'date':
                    #value = formatDate(value[:19])

                #elif valueType == 'datep':
                    #if value[-6:] ==  "-01-01":
                        #value = value.replace('-01-01', '')

                #elif valueType == 'datetime':
                    #value = formatDateTime(value[:19])
                    
                #elif valueType == 'datetimep':
                    #value = formatDateTime(value[:19], True)
                    
                #elif valueType == 'number':
                    #value = "%d" % int(float(value))
                    
                #elif valueType == 'seconds':
                    #value = "%s" % datetime.timedelta(0,int(value),0)
                    ##i = 0
                    ##while True:
                    ##    if not value[i] in ("0", ":"):
                    ##        break
                    ##        
                    ##    else:
                    ##        i += 1

                    ##value = value[i:]

                #elif valueType == 'size':
                    #value = "%s" % "%0.2f MiB" % (int(value)/1024.00/1024.00)
                    
                ##else:
                    ##pass
                
                #if value[:9] == 'nepomuk:/':
                    #resource = Nepomuk.Resource(value)
                    #value = ''
                    #if resource.hasType(NOC('nao:Tag', True)):
                        ##altLabels = QStringListToString(resource.altLabels())
                        #ontLabel = '_' + currOnt + '->%nao:identifier'

                    #elif resource.hasType(NOC('nco:Contact', True)):
                        ##altLabels = QStringListToString(resource.altLabels())
                        #ontLabel =  '_' + currOnt + '->nco:fullname'

                    #elif resource.hasType(NOC('nfo:Folder', True)):
                        #ontLabel = currOnt + '->nfo:fileName'

                    #elif resource.hasType(NOC('nmm:MusicAlbum', True)):
                        #ontLabel = currOnt + '->nie:title'

                    #elif resource.hasType(NOC('rdfs:Resource', True)):
                        #ontLabel = ''
                        #ext = os.path.splitext(toUnicode(resource.genericLabel()))[1][1:]
                        #if ext != '' and ext in QImageReader.supportedImageFormats():
                            #if resource.hasProperty(NOC('nie:url')):
                                #images += [toUnicode(resource.property(NOC('nie:url')).toString())]

                    #else:
                        #value = toUnicode(resource.type())

                    #if value == '':
                        #shorcut = lvalue(knownShortcuts, ontLabel, 0, 1)
                        #if shorcut == None:
                            #shorcut = ontLabel

                        #value = '<!--' + toUnicode(resource.genericLabel()) + '-->' \
                                    #+ self.htmlRenderLink('uri', resource.uri(), resource.genericLabel())
                        #if ontLabel != '':
                            #value += ' ' + self.htmlRenderLink('ontology', shorcut, resource.genericLabel())
                        
                #elif currOnt == '22-rdf-syntax-ns:type':
                    #value = NOCR(value)
                    #if value == defaultType:
                        #value = '<em>' + value + '</em>'
 
                #elif currOnt == 'nie:url':
                    #url = fromPercentEncoding(value)
                    #ext = os.path.splitext(url)[1][1:].lower()
                    #if ext != '' and ext in QImageReader.supportedImageFormats():
                        #if fileExists(value):
                            #images += [value]
                        
                    #value = ''
                    #if url[:7] == 'file://':
                        #value += url
                        #if (os.path.exists(url[7:]) or os.path.islink(url[7:])):
                            #value += ' ' + self.htmlLinkSystemRun % (url)
                            #value += ' ' + self.htmlLinkOpenLocation % (os.path.dirname(url))

                    #elif url[:8] == 'filex://':
                        #value += self.htmlRenderLink('unplugged', \
                                                        #'', \
                                                        #url \
                                                    #)
##                                            url[8:].split('/')[0], \
##                                            '/' + '/'.join(url[8:].split('/')[1:]))

                #elif currOnt == 'nmm:genre':
                    #value = value + ' ' + self.htmlRenderLink('ontology', 'genre', value)

                #else:
                    #if fileExists(value):
                        #ext = os.path.splitext(value)[1][1:]
                        #if ext != '' and ext in QImageReader.supportedImageFormats():
                            #images += [value]

                        #if value[:7] != 'file://':
                            #value = 'file://' + value
                            
                        #value = '<a title=\"%(url)s\" href=\"%(url)s\">%(name)s</a>' \
                                    #% {'url': value, 'name': os.path.basename(value)}

                    #else:
                        ## No es un fichero así que añadimos los links si hay urls.
                        #value = addLinksToText(value)

                #if value != '':
                    #processedData += [[currOnt, ontologyToHuman(currOnt), value]]

        #text = ''
        #if len(processedData) > 0:
            #processedData = sorted(processedData, key=lambda row: row[1] + row[2])
            #oldOnt = ''
            #for row in processedData:
                #if (oldOnt != row[1]):
                    #if text != '':
                        #text += '</td></tr>\n'
                        
                    #text += '<tr><td valign=\"top\" width=\"100px\">' \
                            #'<b title=\"%s\">%s</b>:</td><td>%s' \
                                #% (row[0], row[1], row[2])
                    #oldOnt = row[1]

                #else:
                    #text += ', ' + row[2]
                        
        #if text == '':
            #output += '<p>No data found for the uri %s.</p>\n' % uri

        #else:
            #output += text

        ## Reverse resources.
        #query = "select ?uri ?ont\n" \
                #"   where { " \
                #"       ?uri ?ont <%s> ." \
                #"}" \
                #"order by ?ont" % uri
        #data = self.model.executeQuery(query, Soprano.Query.QueryLanguageSparql)
        #reverseResources = []
        #if data.isValid():
            #while data.next():
                #uri = toUnicode(data["uri"].toString())
                #res = Nepomuk.Resource(uri)
                #val = fromPercentEncoding(toUnicode(res.genericLabel()))
                #reverseResources += [[uri, NOCR(data["ont"].toString()), val]]

            #tmpOutput = ''
            #if len(reverseResources) > 0:
                #reverseResources = sorted(reverseResources, key=lambda revRes: revRes[1] + revRes[2])
                #oldOnt = ''
                #for item in reverseResources:
                    #if oldOnt != item[1]:
                        #if tmpOutput != '':
                            #output += tmpOutput.replace('</a><', '</a>, <')
                            #tmpOutput = ''
                            
                        #output += '<tr><td valign=\"top\" width=\"100px\"><b title=\"%s\">%s</b>:</td><td>' \
                                    #% (item[1], ontologyToHuman(item[1], True))
                        #oldOnt = item[1]

                    #tmpOutput += '<!-- ' + item[2] + '-->' \
                                    #+ self.htmlRenderLink('uri', item[0], item[2]) # \
                                    ##+ ' ' + self.htmlRenderLink('ontology', item[1], item[2])

                #tmpOutput = tmpOutput.replace('</a><', '</a>, <')

            #output += tmpOutput + '</td></tr>\n'

        #output += self.htmlTableFooter + "<hr>\n"
        
        ## Resource images.
        #if len(images) > 0:
            #for image in images:
                #if image[:7] != 'file://':
                    #image = 'file://' + image
                    
                #output += '<img title=\"%(url)s\" style=\"height:auto;width:400px;scalefit=1\" src=\"%(url)s\"><br />\n' \
                            #% {'url': image}
                ##output += imageViewer % {'url': image}

            #output += '<hr>\n'

        #output += self.htmlFooter
        
        #if stdout:
            #print toUtf8(output)
            
        #return output
            
        
    #def formatResultData(self, data = [], structure = [], knownShortcuts = [], \
                            #queryTime = None, renderSize = None, stdout = False):
        #htmlQueryTime = time.time()

        #if data == []:
            #if self.resultData == []:
                #return ""
                
            #data = self.resultData

        #if structure == []:
            #structure = self.resultStructure

        #if knownShortcuts == []:
            #if vartype(self.sparql) != "NoneType":
                #knownShortcuts = self.sparql.shortcuts
        
        #if queryTime == None:
            #queryTime = self.resultTime
                
        #result = self.htmlHeader % {'title': 'Querying Nepomuk', 'script': ""}
        #result += self.htmlTableHeader % {'border': 1, 'cellpadding': 3}

        #if ((renderSize == None) or (renderSize == 0)):
            #renderSize = self.renderSize

        ## Evitar que queden unos pocos registros.
        #if ((len(data) - self.renderedRows - renderSize) <= (self.renderSize / 3)):
            #renderSize = len(data) - self.renderedRows
        
        #resources = []
        #if self.renderedRows <= 0:
            #text = ''

        #else:
            #text = self.renderedCache
            
        #for i in range(self.renderedRows, min(len(data), renderSize + self.renderedRows)):
            #item = data[i]
            #text += '<tr>'
                        
            #resRow = []
            #for subItem in item:
                #if subItem == '':
                    #continue
                  
                #if (subItem[:7] == 'file://'):
                    #subItem = fromPercentEncoding(subItem)
                    #resRow += [['file', subItem]]

                #elif ((subItem[:7] == 'http://') or (subItem[:6] == 'ftp://') or (subItem[:8] == 'https://')):
                    #subItem = fromPercentEncoding(subItem)
                    #resRow += [['url', subItem]]

                #elif (subItem[:8] == 'filex://'):
                    #subItem = fromPercentEncoding(subItem)
                    #resRow += [['filex', subItem]]

                ##elif (subItem[0] == '[') and (subItem[-1] == ']'):
                    ##resRow += [['type', subItem]]

                #elif (subItem[:9] == 'nepomuk:/'):
                    #resRow += [['nepomuk', subItem]]
                    #resourceID = subItem

                #elif (subItem[:6] == 'ont://'):
                    #resRow = [item]
                    #break

                #else:
                    #resRow += [['', subItem]]

            #resources += [resRow]
            
        #itemType = ''
        #for row in resources:
            #links = ''
            #textData = ''
            #queryLink = ''
            #nepomukResource = None
            #for i in range(0, len(row)):
                #item = row[i]

                ## URI.
                #if item[0] == 'nepomuk':
                    #nepomukResource = Nepomuk.Resource(item[1])
                    #itemType = toUnicode(nepomukResource.resourceType().toString().split('#')[1])
                    
                    #htmlstr = self.htmlLinkProperties % (item[1])
                    #htmlstr += ' ' + self.htmlLinkRemove % (item[1])
                    #if links == '':
                        #links = htmlstr

                    #else:
                        #links = htmlstr + links

                ## File URL.
                #elif item[0] == 'file':
                    #links += ' ' + self.htmlLinkDolphin % (item[1])
                    #links += ' ' + self.htmlLinkKonqueror % (item[1])

                    #if textData != '':
                        #textData += '<br />'

                    #if (os.path.exists(item[1][7:]) or os.path.islink(item[1][7:])):
                        #textData += self.htmlRenderLink("uri", nepomukResource.uri(), os.path.basename(item[1]))
                        #textData += ' ' + self.htmlLinkSystemRun % (item[1])
                        #textData += ' ' + self.htmlLinkOpenLocation % (os.path.dirname(item[1]))

                    #else:
                        #textData += self.htmlRenderLink('url', item[1], os.path.basename(item[1]))

                ## Filex URL.
                #elif item[0] == 'filex':
                    #if textData != '':
                        #textData += '<br />'


                    #textData += self.htmlRenderLink('unplugged', \
                                                        #nepomukResource.uri(), \
                                                        #item[1]\
                                                    #)
                    ##                        item[1][8:].split('/')[0], \
                    ##                        '/' + '/'.join(item[1][8:].split('/')[1:]))

                ## URL.
                #elif item[0] == 'url':
                    #if textData != '':
                        #textData += '<br />'

                    #textData += self.htmlRenderLink('url', item[1], os.path.basename(item[1]))
                        
                ## Special, to control properties.
                #elif item[0][:6] == 'ont://':
                    #itemType = ontologyToHuman(item[0][6:])
                    #if textData != '':
                        #textData += '<br />'

                    #textData += item[1] + ' ' + self.htmlRenderLink('ontology', item[0][6:], item[1])

                #else:
                    #if queryLink == '':
                        #queryLink = item[1]

                    #if textData != '':
                        #textData += '<br />'

                    #itemTypeLower = itemType.lower()
                    #if itemTypeLower == 'contact':
                        ## En las queries genéricas la columna se llama url.
                        ##TODO: mal hack, esto es confuso, mirar de arreglarlo.
                        #if structure[i] == 'fullname' or structure[i] == 'url':
                            #textData += self.htmlRenderLink('uri', nepomukResource.uri(), item[1]) \
                                            #+ ' ' + self.htmlRenderLink('contact', item[1])
                            #links += ' ' + self.htmlLinkDolphin % (nepomukResource.uri())
                            #links += ' ' + self.htmlLinkKonqueror % (nepomukResource.uri())

                        #elif structure[i] == '_n_f_t_m_ex_':
                            #textData = item[1]

                    #elif itemTypeLower == 'tag':
                        ## En las queries genéricas la columna se llama url.
                        ##TODO: mal hack, esto es confuso, mirar de arreglarlo.
                        #if structure[i] == 'prefLabel' or structure[i] == 'url':
                            #if nepomukResource != None:
                                #textData += self.htmlRenderLink('uri', nepomukResource.uri(), item[1]) \
                                                #+ ' ' + self.htmlRenderLink('tag', item[1])
                                            
                        #else:
                            ##TODO: mal hack, esto es confuso, mirar de arreglarlo.
                            #if structure[i] == 'title':
                                #textData += '%s: %s' % (ontologyToHuman('nie:altLabel'), item[1])

                            #elif structure[i] == '_n_f_t_m_ex_':
                                #textData = item[1]
                                
                            #else:
                                #textData += '%s: %s' % (ontologyToHuman(structure[i]), item[1])

                    #else:
                        #textData += '<em>' + item[1] + '</em>'

            #if nepomukResource == None:
                #if itemType == '':
                    #itemType = 'Property'

            ##else:
            ##    itemType = toUnicode(nepomukResource.resourceType().toString().split('#')[1])

            #if itemType == '':
                #itemType = 'unknown'

            #else:
                #if queryLink != '':
                    #itemTypeLower = itemType.lower()
                    #if itemTypeLower == 'musicalbum':
                        #textData = textData.replace('<em>', '').replace('</em>', '')
                        #textData = self.htmlRenderLink('uri', nepomukResource.uri(), textData) \
                                    #+ ' ' + self.htmlRenderLink('album', textData)
                        
                        #query = 'select distinct ?performer ?name\n' \
                                #'where {\n' \
                                    #'   ?uri nmm:musicAlbum <%s> .\n' \
                                    #'   ?uri nmm:performer ?performer . ?performer nco:fullname ?name\n' \
                                #'}\n' \
                                #'order by ?name' \
                                #% nepomukResource.uri()
                        #performers = self.model.executeQuery(query, Soprano.Query.QueryLanguageSparql)
                        #additionalData = ''
                        #if performers.isValid():
                            #while performers.next():
                                #if additionalData != '':
                                    #additionalData += ', '
                                    
                                #additionalData += self.htmlRenderLink('uri', performers["performer"].toString(), performers["name"].toString()) \
                                                    #+ ' ' + self.htmlRenderLink('performer', performers["name"].toString())
                                                    
                        #if additionalData != '':
                            #additionalData = '<br />%s: ' % _('Performer') + additionalData

                        #textData += additionalData
                        
                        #links += ' ' + self.htmlLinkDolphin % (nepomukResource.uri())
                        #links += ' ' + self.htmlLinkKonqueror % (nepomukResource.uri())
                    
                    #elif itemTypeLower == 'musicpiece':
                        ## Title:, disc and track before title.
                        #trackNumber = nepomukResource.property(NOC('nmm:trackNumber')).toString()
                        #if len(trackNumber) < 2:
                            #trackNumber = '0' + trackNumber
                            
                        #discNumber = nepomukResource.property(NOC('nmm:setNumber')).toString()
                        #if discNumber != '':
                            #discNumber += 'x'
                            
                        #textData = textData.replace('<br /><em>', '<br />%s: <em>%s%s - ' % (_('Title'), discNumber, trackNumber))
                        
                        ## Album title.
                        #tmpUri = nepomukResource.property(NOC('nmm:musicAlbum')).toString()
                        #query = 'select distinct ?title\n' \
                            #'where {\n' \
                                #'   <%s> nie:title ?title .\n' \
                            #'}\n' \
                            #% tmpUri
                        #queryResultSet = self.model.executeQuery(query, Soprano.Query.QueryLanguageSparql)
                        #additionalData = ''
                        #if queryResultSet.isValid():
                            ## I known, there is only one possible record but...
                            #while queryResultSet.next():
                                #if additionalData != '':
                                    #additionalData += ', '

                                #additionalData += self.htmlRenderLink('uri', tmpUri, queryResultSet["title"].toString()) \
                                                    #+ ' ' + self.htmlRenderLink('album', queryResultSet["title"].toString())

                        #if additionalData != '':
                            ##trackNumber = nepomukResource.property(NOC('nmm:trackNumber')).toString()
                            ##textData += '<br />%s: %s, %s %s' % \
                            ##                (_('Album'), additionalData, _('track'), trackNumber)
                            #textData += '<br />%s: ' % (_('Album')) + additionalData
                            ##discNumber = nepomukResource.property(NOC('nmm:setNumber')).toString()
                            ##if discNumber != '':
                            ##    textData += ', %s %s' % (_('disc'), discNumber)

                        ## Performer.
                        #tmpUri = nepomukResource.property(NOC('nmm:performer')).toString()
                        #query = 'select distinct ?fullname\n' \
                            #'where {\n' \
                                #'   <%s> nco:fullname ?fullname .\n' \
                            #'}\n' \
                            #% tmpUri
                        #queryResultSet = self.model.executeQuery(query, Soprano.Query.QueryLanguageSparql)
                        #additionalData = ''
                        #if queryResultSet.isValid():
                            ## I known, there is only one possible record but...
                            #while queryResultSet.next():
                                #if additionalData != '':
                                    #additionalData += ', '

                                #additionalData += self.htmlRenderLink('uri', tmpUri, queryResultSet["fullname"].toString()) \
                                                    #+ ' ' + self.htmlRenderLink('contact', queryResultSet["fullname"].toString())

                        #if additionalData != '':
                            #textData += '<br />%s: ' % _('Performer') + additionalData

                    #elif itemTypeLower == 'tvshow':
                        #additionalData = "<br />Episode: <em>%sx%02d</em> " \
                                            #% (toUnicode(nepomukResource.property(NOC('nmm:season', True)).toString()), \
                                                #int(toUnicode(nepomukResource.property(NOC('nmm:episodeNumber')).toString())))
                        #textData = textData.replace('<br />', additionalData)

            #text += '<td>' + textData + '</td><td>' + itemType + '</td>'
            #text += self.htmlLinks % links
            #text += '</tr>\n'

            #if stdout:
                #print toUtf8(text)

            #self.renderedRows += 1

        #self.renderedCache = text
        #if self.renderedRows < len(data):
            #text += '<td><a href="render:/more">%s more</a>, <a href="render:/all">all records</a></td>' \
                    #'<td>%s of %s records</td>' \
                        #% (self.renderSize, self.renderedRows, len(data))
            #text += self.htmlLinks % ''

        
        #text += self.htmlTableFooter
        #text += self.htmlTime % {'records': len(data), 'seconds': queryTime, 'sechtml': time.time() - htmlQueryTime}
        #if stdout:
            #print toUtf8(text)

        #result += text + self.htmlFooter
        #if stdout:
            #print toUtf8(result)
    
        #return result


    def execQuery(self, searchString = '', overwriteQueriesList = False):
        self.leSearch.readOnly = True
        self.setCursor(Qt.BusyCursor)
        self.repaint()

        self.renderedRows = 0
        self.renderedCache = ''
        
        self.resultData = []
        self.resultStructure = []
        self.resultTime = None

        searchEngine = 1 # Default is v1 engine.
        if searchString == '':
            searchString = toUnicode(self.leSearch.text().trimmed().toUtf8())
            if searchString[:3].lower() in ('e0 ', 'e1 ', 'e2 '):
                searchEngine = int(searchString[1:2])
                
            textTyped = True

        else:
            if searchString[:3].lower() in ('e0 ', 'e1 ', 'e2 '):
                searchEngine = int(searchString[1:2])
                
            textTyped = False

        #if True:
        try:
            self.sparql = cSparqlBuilder()
            if searchString[:9] == 'nepomuk:/':
                oDataFormat = cDataFormat(searchString, self.model)
                output = oDataFormat.formatResourceInfo(searchString, self.sparql.shortcuts, self.sparql.ontologyTypes)
                #output = self.formatResourceInfo(searchString, self.sparql.shortcuts, self.sparql.ontologyTypes)
                if textTyped:
                    # Cache must be trunked in current position if query changed.
                    if ((self.queriesIndex >= 0) and (self.queriesIndex < len(self.cache))):
                        if self.cache[self.queriesIndex].searchString != searchString:
                            self.cache = self.cache[:self.queriesIndex + 1]

                    if (self.cache == []) or (self.cache[self.queriesIndex].searchString != searchString):
                        self.cache += [oDataFormat]
                        self.queriesIndex += 1

                    else:
                        self.cache[self.queriesIndex] = oDataFormat

                    if overwriteQueriesList:
                        self.navigationData = []

              
            elif searchString != '':

                if searchEngine == 0:
                    oNQP = Nepomuk.Query.QueryParser()
                    query = oNQP.parse(searchString[3:]).toSparqlQuery()
                    self.resultData, self.resultStructure, self.resultTime = self.sparql.executeQuery(query)
                    if (self.verboseMode and sys.stdout.isatty()):
                        print toUtf8(query)

                    oDataFormat = cDataFormat(searchString, self.model)
                    output = oDataFormat.formatAsHtml(self.resultData, self.resultStructure, self.resultTime)

                    # Cache must be trunked in current position if query changed.
                    if ((self.queriesIndex >= 0) and (self.queriesIndex < len(self.cache))):
                        if self.cache[self.queriesIndex].searchString != searchString:
                            self.cache = self.cache[:self.queriesIndex + 1]
                                            
                    if (self.cache == []) or (self.cache[self.queriesIndex].searchString != searchString):
                        self.cache += [oDataFormat]
                        self.queriesIndex += 1

                    else:
                        self.cache[self.queriesIndex] = oDataFormat

                    self.navigationData = self.cache[self.queriesIndex].data

                elif searchEngine == 2:
                    raise Exception('v2 engine not available.')

                else:
                    self.sparql.stdoutQuery = (self.verboseMode and sys.stdout.isatty())
                    self.sparql.columns = '?x0 AS ?id ' + self.sparql.columns
                    self.resultData, self.resultStructure, self.resultTime = self.sparql.executeQuery(self.sparql.buildQuery(searchString))
                    self.warningsList = self.sparql.warningsList
                    self.sparql.warningsList = []
                    
                    #output = self.formatResultData()
                    oDataFormat = cDataFormat(searchString, self.model)
                    output = oDataFormat.formatAsHtml(self.resultData, self.resultStructure, self.resultTime)

                    # Cache must be trunked in current position if query changed.
                    if ((self.queriesIndex >= 0) and (self.queriesIndex < len(self.cache))):
                        if self.cache[self.queriesIndex].searchString != searchString:
                            self.cache = self.cache[:self.queriesIndex + 1]

                    if (self.cache == []) or (self.cache[self.queriesIndex].searchString != searchString):
                        self.cache += [oDataFormat]
                        self.queriesIndex += 1

                    else:
                        self.cache[self.queriesIndex] = oDataFormat

                    self.navigationData = self.cache[self.queriesIndex].data

            else:
                raise Exception('Please, type something.')

            #if (textTyped or (self.queriesIndex < 0)):
                #if ((self.queriesIndex + 1) < len(self.queries)):
                    #self.queries = self.queries[:self.queriesIndex + 1]

                #if (self.queries != []):
                    #if (self.queries[self.queriesIndex] != searchString):
                        #if overwriteQueriesList:
                            #self.queries[self.queriesIndex] = searchString

                        #else:
                            #self.queries += [searchString]
                            #self.queriesIndex = len(self.queries) - 1

                #else:
                    #self.queries = [searchString]
                    #self.queriesIndex = 0
                
        #try:
        #    pass
        
        except:
            msgError = "%s" % sys.exc_info()[1]
            if msgError == 'help':
                output = self.buildHelp(self.sparql)

            elif msgError == 'quit':
                quit()

            else:
                output = "<html>\n  <head>\n    <title>%(title)s</title>\n    " \
                            "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">" \
                            "\n  </head>\n<body><b>error:</b> %(error)s" \
                            "%(powered)s</body>\n</html>" \
                            % {'title': 'Querying Nepomuk', \
                                'error': sys.exc_info()[1], \
                                'powered': PROGRAM_HTML_POWERED \
                                }

        self.pendingQuery = False
        self.wvOutput.setHtml(output)
        self.setCursor(Qt.ArrowCursor)
        self.leSearch.readOnly = False
        self.repaint()

        # Handle possible warnings.
        warningMsg = ""
        for warning in self.warningsList:
            if warningMsg != "":
                warningMsg += "\n\n"

            if warning[0] == "BUG001":
                warningMsg += "There is a know bug using negation without a shortcut.\n" \
                        "Please notice that the results may be inaccurate.\n\n"
                for i in range(1, len(warning)):
                    warningMsg += "Change \"%s\" for something like \"title:%s\" to solve this issue.\n" \
                    % (warning[i], warning[i])

            #else:
                #pass

        self.warningsList = []

        if warningMsg != "":
            QMessageBox.warning(self, "%s - %s" % (PROGRAM_NAME, _("warning")), warningMsg)

        #if ((self.queriesIndex >= 0) and (self.queries[self.queriesIndex][:9] != "nepomuk:/")):
            #self.navigationData = self.resultData

  
def buildHelp():
    print "%(name)s %(version)s (%(date)s)\n" \
              % {'name': PROGRAM_NAME, 'version': PROGRAM_VERSION_VERSION, 'date': PROGRAM_VERSION_DATE}
              
    print "Usage: %s command | query\n" \
          "\n" \
          "commands:\n" \
          "  --help\t\t--\tShows this help\n" \
          "  --gui\t\t\t--\tForce gui mode in console mode\n" \
          "  --verbose=MODE\t--\tMode: ON, OFF (defaults ON with --gui parameter)\n" \
          "\n" \
          "query:\n" \
          "  Consult the help in gui mode\n" \
          % PROGRAM_NAME
  

def main(args):

    #appName = PROGRAM_NAME
    #catalog = PROGRAM_NAME
    #programName = ki18n(PROGRAM_NAME)
    #version = PROGRAM_VERSION_VERSION
    #description = ki18n("An alternate search engine for Nepomuk inspired in Google search syntax.")
    #license = KAboutData.License_GPL
    #copyright = ki18n("(C) 2011 Ignacio Serantes")
    #text = ki18n("A search engine for Nepomuk.")
    #homePage = "http://kde-apps.org/content/show.php/Nepoogle?content=145505"
    #bugEmail = "kde@aynoa.net"

    #aboutData = KAboutData(appName, catalog, programName, version,
                            #description, license, copyright, text, homePage,
                            #bugEmail)

    #KCmdLineArgs.init(sys.argv, aboutData)

    #options = KCmdLineOptions()
    #options.add("--help", ki18n("this help"))
    #options.add("--gui", ki18n("force gui mode in console"))
    #options.add("--stdout", ki18n("force stdout in console mode"))
    #options.add("--nostdout", ki18n("force no stdout in gui mode"))
    #KCmdLineArgs.addCmdLineOptions(options)
    
    gui = not sys.stdout.isatty()
    verboseMode = None
    parameters = toUnicode('')
    paramOption = ""
    for i in range(1, len(args)):
        parameter = toUnicode(args[i].strip())

        if parameter.lower() == '--help':
            buildHelp()
            quit()
        
        elif parameter.lower() == '--gui':
            gui = True
            continue
        
        elif parameter.lower()[:9] == '--verbose':
            paramValue = parameter.lower()[9:]
            if paramValue == '':
                if verboseMode == None:
                    verboseMode = True
                    
            elif paramValue == '=on':
                verboseMode = True
                
            elif paramValue == '=off':
                verboseMode = False
                
            continue
        
        elif parameter.find(' ') >= 0:
            j = parameter.rfind(':')
            if j >= 0:
                parameter = parameter[:j+1] + '"' + parameter[j+1:] + '"'
                
            else:
                parameter = '"' + parameter + '"'
            
        parameters += parameter + ' '

    searchString = parameters.strip()
    if gui:
        if verboseMode == None:
            verboseMode = gui

        #app = KApplication()
        #window = Nepoogle(searchString)
        #window.show()

        #if searchString != '':
        #    window.execQuery()
        
        app = QApplication(args)
        nepoogle = Nepoogle(None, searchString, verboseMode)
        nepoogle.show()
        nepoogle.repaint()

        if searchString != '':
            nepoogle.execQuery()

        sys.exit(app.exec_())

    else:
        if verboseMode == None:
            verboseMode == False

        searchEngine = 1 # Default is v1 engine.

        if searchString[:3].lower() in ('e0 ', 'e1 ', 'e2 '):
            searchEngine = int(searchString[1:2])
            #searchString = searchString[3:]

        output = "%(title)s\n" % {'title': 'Querying Nepomuk' }
        print toUtf8(output)
        
        #if True:
        try:
            warningsList = []
            oSparql = cSparqlBuilder()
            if searchString != '':

                if searchEngine == 0:
                    oNQP = Nepomuk.Query.QueryParser()
                    data, structure, time = oSparql.executeQuery(oNQP.parse(searchString).toSparqlQuery())

                elif searchEngine == 2:
                    raise Exception('v2 engine not available.')

                else:
                    oSparql.stdoutQuery = verboseMode
                    oSparql.columns = '?x0 AS ?id ' + oSparql.columns
                    data, structure, time = oSparql.executeQuery(oSparql.buildQuery(searchString))
                    warningsList =  oSparql.warningsList
                    oSparql.warningsList = []

                oDataFormat = cDataFormat(searchString)
                oDataFormat.formatAsText(data, structure, time)
                output = "\n%(records)s records found in %(seconds)f seconds.\n" \
                            "--\n" \
                            "Powered by %(name)s %(version)s (%(date)s)" \
                            % {'records': len(data), \
                                'seconds': time, \
                                'name': PROGRAM_NAME, \
                                'version': PROGRAM_VERSION_VERSION, \
                                'date': PROGRAM_VERSION_DATE \
                                }
                                
                # Handle possible warnings.
                warningMsg = ""
                for warning in warningsList:
                    if warningMsg != "":
                        warningMsg += "\n\n"

                    if warning[0] == "BUG001":
                        warningMsg += "There is a know bug using negation without a shortcut.\n" \
                                "Please notice that the results may be inaccurate.\n\n"
                        for i in range(1, len(warning)):
                            warningMsg += "Change \"%s\" for something like \"title:%s\" to solve this issue.\n" \
                            % (warning[i], warning[i])

                    #else:
                        #pass

                warningsList = []

                if warningMsg != "":
                    output += '\n\nWARNING: ' + toUtf8(warningMsg)
                    
            else:
                raise Exception('Please, type something.')

        #try:
        #    pass

        except:
            msgError = "%s" % sys.exc_info()[1]
            if msgError == 'help':
                output = buildHelp()

            else:
                output = "\nerror: %(error)s\n" \
                            "\n--\n" \
                            "Powered by %(name)s %(version)s (%(date)s)" \
                            % {'title': 'Querying Nepomuk', \
                                'error': sys.exc_info()[1], \
                                'name': PROGRAM_NAME, \
                                'version': PROGRAM_VERSION_VERSION, \
                                'date': PROGRAM_VERSION_DATE \
                                }

        print toUtf8(output)
        

if __name__=="__main__":
    os.putenv("DISPLAY", ":0")
    main(sys.argv)
